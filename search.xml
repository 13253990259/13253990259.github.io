<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.手写MyBatis</title>
    <url>/gxblog/2020/06/25/6.%E6%89%8B%E5%86%99MyBatis/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MyBatis应用分析与最佳实践</title>
    <url>/gxblog/2020/04/28/1.MyBatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>动态sql</tag>
        <tag>自定义插件</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列之RabbitMQ</title>
    <url>/gxblog/2020/04/26/day05%20%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ(2%E6%97%B652%E5%88%86)/</url>
    <content><![CDATA[<h1 id="day05-消息中间件RabbitMQ-2时52分"><a href="#day05-消息中间件RabbitMQ-2时52分" class="headerlink" title="day05 消息中间件RabbitMQ (2时52分)"></a>day05 消息中间件RabbitMQ (2时52分)</h1><h2 id="1-页面发布-需求分析-11分28秒"><a href="#1-页面发布-需求分析-11分28秒" class="headerlink" title="1.页面发布-需求分析 (11分28秒)"></a>1.页面发布-需求分析 (11分28秒)</h2><p><a href="https://i.loli.net/2020/05/08/n57CcxgQNul6Per.jpg" target="_blank" rel="noopener">https://i.loli.net/2020/05/08/n57CcxgQNul6Per.jpg</a></p>
<p><img src="assets/1542500496415.png" alt="1542500496415"></p>
<a id="more"></a>


<p>业务流程如下：<br>1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。<br>2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。<br>3、静态化成功后，向消息队列发送页面发布的消息。<br>页面发布的最终目标是将页面发布到服务器。<br>通过消息队列将页面发布的消息发送给各各服务器。<br>3、消息队列负责将消息发送给各各服务器上部署的Cms Client(Cms客户端)。<br>在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。<br>4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并将Html文件存储在本地服务器。<br>CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。</p>
<h2 id="2-RabbitMQ研究-RabbitMQ介绍-5分26秒"><a href="#2-RabbitMQ研究-RabbitMQ介绍-5分26秒" class="headerlink" title="2.RabbitMQ研究-RabbitMQ介绍 (5分26秒)"></a>2.RabbitMQ研究-RabbitMQ介绍 (5分26秒)</h2><p>MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message<br>Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开<br>发中应用非常广泛。RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<h3 id="开发中消息队列通常有如下应用场景："><a href="#开发中消息队列通常有如下应用场景：" class="headerlink" title="开发中消息队列通常有如下应用场景："></a>开发中消息队列通常有如下应用场景：</h3><p>1、任务异步处理。<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。<br>2、应用程序解耦合<br>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p>
<h3 id="市场上还有哪些消息队列？"><a href="#市场上还有哪些消息队列？" class="headerlink" title="市场上还有哪些消息队列？"></a>市场上还有哪些消息队列？</h3><p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p>
<h3 id="为什么使用RabbitMQ呢？"><a href="#为什么使用RabbitMQ呢？" class="headerlink" title="为什么使用RabbitMQ呢？"></a>为什么使用RabbitMQ呢？</h3><p>1、使得简单，功能强大。<br>2、基于AMQP协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于Erlang语言。<br>5、Spring Boot默认已集成RabbitMQ</p>
<h3 id="AMQP是什么-？"><a href="#AMQP是什么-？" class="headerlink" title="AMQP是什么 ？"></a>AMQP是什么 ？</h3><p><img src="assets/1542500632001.png" alt="1542500632001"></p>
<p>总结：AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。<br>官方：<a href="http://www.amqp.org/" target="_blank" rel="noopener">http://www.amqp.org/</a></p>
<h3 id="JMS是什么-？"><a href="#JMS是什么-？" class="headerlink" title="JMS是什么 ？"></a>JMS是什么 ？</h3><p><img src="assets/1542500625579.png" alt="1542500625579"></p>
<p>总结：<br>JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的<br>jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消<br>息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。</p>
<h2 id="3-RabbitMQ研究-工作原理-6分28秒"><a href="#3-RabbitMQ研究-工作原理-6分28秒" class="headerlink" title="3.RabbitMQ研究-工作原理 (6分28秒)"></a>3.RabbitMQ研究-工作原理 (6分28秒)</h2><p><img src="assets/1542500760568.png" alt="1542500760568"></p>
<p>组成部分说明如下：<br>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</p>
<p>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</p>
<p>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。<br>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。<br>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。<br>消息发布接收流程：<br>—–发送消息—–<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）<br>—-接收消息—–<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。</p>
<h2 id="4-RabbitMQ研究-安装RabbitMQ-9分3秒"><a href="#4-RabbitMQ研究-安装RabbitMQ-9分3秒" class="headerlink" title="4.RabbitMQ研究-安装RabbitMQ (9分3秒)"></a>4.RabbitMQ研究-安装RabbitMQ (9分3秒)</h2><h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h3><p><img src="assets/1542502251460.png" alt="1542502251460"></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><img src="assets/1542502390155.png" alt="1542502390155"></p>
<p><img src="assets/1542502423843.png" alt="1542502423843"></p>
<h3 id="启动rabbitmq管理界面"><a href="#启动rabbitmq管理界面" class="headerlink" title="启动rabbitmq管理界面"></a>启动rabbitmq管理界面</h3><p><img src="assets/1542502115646.png" alt="1542502115646"></p>
<h3 id="重启RabbitMQ服务"><a href="#重启RabbitMQ服务" class="headerlink" title="重启RabbitMQ服务"></a>重启RabbitMQ服务</h3><p><img src="assets/1542502176676.png" alt="1542502176676"></p>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p>
<p><img src="assets/1542534338931.png" alt="1542534338931"></p>
<h2 id="5-RabbitMQ研究-入门程序-生产者-23分18秒"><a href="#5-RabbitMQ研究-入门程序-生产者-23分18秒" class="headerlink" title="5.RabbitMQ研究-入门程序-生产者 (23分18秒)"></a>5.RabbitMQ研究-入门程序-生产者 (23分18秒)</h2><p><img src="assets/1542535212320.png" alt="1542535212320"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rabbitmq的入门程序</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立新连接</span></span><br><span class="line">            connection = connectionFactory.newConnection();</span><br><span class="line">            <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">            <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细</span></span><br><span class="line"><span class="comment">             * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(QUEUE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细：</span></span><br><span class="line"><span class="comment">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）</span></span><br><span class="line"><span class="comment">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">             * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">             * 4、body，消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//消息内容</span></span><br><span class="line">            String message = <span class="string">"hello world 黑马程序员"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"send to mq "</span>+message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="comment">//先关闭通道</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="assets/1542534402655.png" alt="1542534402655"></p>
<h2 id="6-RabbitMQ研究-入门程序-消费者-16分47秒"><a href="#6-RabbitMQ研究-入门程序-消费者-16分47秒" class="headerlink" title="6.RabbitMQ研究-入门程序-消费者 (16分47秒)"></a>6.RabbitMQ研究-入门程序-消费者 (16分47秒)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入门程序消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-17 9:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立新连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">//消息内容</span></span><br><span class="line">                String message= <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"receive message:"</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动Consumer01，程序不会自动结束，此时运行Producer01就会发送消息，Consumer01就会直接接收到消息。</p>
<p><img src="assets/1542534520399.png" alt="1542534520399"></p>
<p>Mq中不会显示待发消息了</p>
<p><img src="assets/1542534622822.png" alt="1542534622822"></p>
<h2 id="7-RabbitMQ研究-工作模式-工作队列模式-7分10秒"><a href="#7-RabbitMQ研究-工作模式-工作队列模式-7分10秒" class="headerlink" title="7.RabbitMQ研究-工作模式-工作队列模式 (7分10秒)"></a>7.RabbitMQ研究-工作模式-工作队列模式 (7分10秒)</h2><p>RabbitMQ有以下几种工作模式 ：<br>1、Work queues<br>2、Publish/Subscribe<br>3、Routing<br>4、Topics<br>5、Header<br>6、RPC</p>
<p><img src="assets/1542534883570.png" alt="1542534883570"></p>
<p>启动多个Consumer，会轮询接收消息。</p>
<h2 id="8-RabbitMQ研究-工作模式-发布订阅模式-生产者-15分17秒"><a href="#8-RabbitMQ研究-工作模式-发布订阅模式-生产者-15分17秒" class="headerlink" title="8.RabbitMQ研究-工作模式-发布订阅模式-生产者 (15分17秒)"></a>8.RabbitMQ研究-工作模式-发布订阅模式-生产者 (15分17秒)</h2><p><img src="assets/1542535226948.png" alt="1542535226948"></p>
<h3 id="发布订阅模式："><a href="#发布订阅模式：" class="headerlink" title="发布订阅模式："></a>发布订阅模式：</h3><p>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息</p>
<h2 id="9-RabbitMQ研究-工作模式-发布订阅模式-消费者-11分9秒"><a href="#9-RabbitMQ研究-工作模式-发布订阅模式-消费者-11分9秒" class="headerlink" title="9.RabbitMQ研究-工作模式-发布订阅模式-消费者 (11分9秒)"></a>9.RabbitMQ研究-工作模式-发布订阅模式-消费者 (11分9秒)</h2><h2 id="10-RabbitMQ研究-工作模式-路由工作模式介绍-5分53秒"><a href="#10-RabbitMQ研究-工作模式-路由工作模式介绍-5分53秒" class="headerlink" title="10.RabbitMQ研究-工作模式-路由工作模式介绍 (5分53秒)"></a>10.RabbitMQ研究-工作模式-路由工作模式介绍 (5分53秒)</h2><p><img src="assets/1542538737391.png" alt="1542538737391"></p>
<p>路由模式：<br>1、每个消费者监听自己的队列，并且设置routingkey。<br>2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。</p>
<h2 id="11-RabbitMQ研究-工作模式-路由工作模式测试-12分59秒"><a href="#11-RabbitMQ研究-工作模式-路由工作模式测试-12分59秒" class="headerlink" title="11.RabbitMQ研究-工作模式-路由工作模式测试 (12分59秒)"></a>11.RabbitMQ研究-工作模式-路由工作模式测试 (12分59秒)</h2><h2 id="12-RabbitMQ研究-工作模式-统配符工作模式测试-16分29秒"><a href="#12-RabbitMQ研究-工作模式-统配符工作模式测试-16分29秒" class="headerlink" title="12.RabbitMQ研究-工作模式-统配符工作模式测试 (16分29秒)"></a>12.RabbitMQ研究-工作模式-统配符工作模式测试 (16分29秒)</h2><p><img src="assets/1542538850709.png" alt="1542538850709"></p>
<p>路由模式：<br>1、每个消费者监听自己的队列，并且设置带统配符的routingkey。<br>2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>
<h2 id="13-RabbitMQ研究-工作模式-header和rpc工作模式-5分47秒"><a href="#13-RabbitMQ研究-工作模式-header和rpc工作模式-5分47秒" class="headerlink" title="13.RabbitMQ研究-工作模式-header和rpc工作模式 (5分47秒)"></a>13.RabbitMQ研究-工作模式-header和rpc工作模式 (5分47秒)</h2><p>header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配<br>队列。<br>案例：<br>根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种<br>通知类型都接收的则两种通知都有效。</p>
<p><img src="assets/1542538910666.png" alt="1542538910666"></p>
<p>RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：<br>1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。<br>2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果<br>3、服务端将RPC方法 的结果发送到RPC响应队列<br>4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。</p>
<h2 id="14-RabbitMQ研究-与springboot整合-搭建环境-5分56秒"><a href="#14-RabbitMQ研究-与springboot整合-搭建环境-5分56秒" class="headerlink" title="14.RabbitMQ研究-与springboot整合-搭建环境 (5分56秒)"></a>14.RabbitMQ研究-与springboot整合-搭建环境 (5分56秒)</h2><h2 id="15-RabbitMQ研究-与springboot整合-声明交换机和队列-6分48秒"><a href="#15-RabbitMQ研究-与springboot整合-声明交换机和队列-6分48秒" class="headerlink" title="15.RabbitMQ研究-与springboot整合-声明交换机和队列 (6分48秒)"></a>15.RabbitMQ研究-与springboot整合-声明交换机和队列 (6分48秒)</h2><h2 id="16-RabbitMQ研究-与springboot整合-生产者代码-6分12秒"><a href="#16-RabbitMQ研究-与springboot整合-生产者代码-6分12秒" class="headerlink" title="16.RabbitMQ研究-与springboot整合-生产者代码 (6分12秒)"></a>16.RabbitMQ研究-与springboot整合-生产者代码 (6分12秒)</h2><h2 id="17-RabbitMQ研究-与springboot整合-消费者代码-6分15秒"><a href="#17-RabbitMQ研究-与springboot整合-消费者代码-6分15秒" class="headerlink" title="17.RabbitMQ研究-与springboot整合-消费者代码 (6分15秒)"></a>17.RabbitMQ研究-与springboot整合-消费者代码 (6分15秒)</h2>]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis体系结构与工作原理</title>
    <url>/gxblog/2020/06/25/2.MyBatis%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1、掌握MyBatis的主要工作流程"><a href="#1、掌握MyBatis的主要工作流程" class="headerlink" title="1、掌握MyBatis的主要工作流程"></a>1、掌握MyBatis的主要工作流程</h1><h3 id="1、解析配置文件"><a href="#1、解析配置文件" class="headerlink" title="1、解析配置文件"></a>1、解析配置文件</h3><p>首先在MyBatis 启动的时候我们要去解析配置文件， 包括全局配置文件和映射器配置文件，这里面包含了我们怎么控制MyBatis 的行为，和我们要对数据库下达的指令，也就是我们的SQL 信息。我们会把它们解析成一个Configuration 对象。</p>
<h3 id="2、创建工厂类"><a href="#2、创建工厂类" class="headerlink" title="2、创建工厂类"></a>2、创建工厂类</h3><a id="more"></a>

<p>接下来就是我们操作数据库的接口， 它在应用程序和数据库中间， 代表我们跟数<br>据库之间的一次连接：这个就是SqlSession 对象。<br>我们要获得— 个会话， 必须有— 个会话工厂SqlSessionFactory 。<br>Sq I Session Factory 里面又必须包含我们的所有的配置信息， 所以我们会通过一个<br>Builder 来创建工厂类。<br>MyBatis是对JDBC 的封装也就是意味着底层— 定会出现JDBC 的—些核心对象，<br>比如执行SQL 的Statement，结果集ResultSet。在Mybatis 里面， SqlSession 只是提<br>供给应用的—个接口， 还不是SQL的真正的执行对象。</p>
<h3 id="3、创建会话"><a href="#3、创建会话" class="headerlink" title="3、创建会话"></a>3、创建会话</h3><p>SqlSession 持有了—个Executor 对象， 用来封装对数据库的操作。<br>在执行器Executor 执行query 或者update 操作的时候我们创建—系列的对象，<br>来处理参数、执行SQL, 处理结果集，这里我们把它简化成—个对象：StatementHandler,<br>可以把它理解为对Statement 的封装，这个就是MyBatis 主要的工作流程， 如图：</p>
<p><img src="https://i.loli.net/2020/05/14/2Z4RSmwJNdypocP.png" alt="image.png"></p>
<h1 id="2、掌握MyBatis的架构分层与模块划分"><a href="#2、掌握MyBatis的架构分层与模块划分" class="headerlink" title="2、掌握MyBatis的架构分层与模块划分"></a>2、掌握MyBatis的架构分层与模块划分</h1><p><img src="https://i.loli.net/2020/05/14/bZ1rUgzuM8ySn7c.png" alt="image.png"></p>
<p>按照功能职责的不同， 所有的package 可以分成不同的工作层次。</p>
<p><img src="https://i.loli.net/2020/05/14/hvNUuCfanLPEsB5.png" alt="image.png"></p>
<p><strong>接口层:</strong></p>
<p>首先接口层是我们打交道最多的。核心对象是SqlSession ，它是上层应用和MyBatis<br>打交道的桥梁， SqlSession 上定义了非常多的对数据库的操作方法。接口层在接收到调用请求的时候， 会调用核心处理层的相应模块来完成具体的数据库操作。</p>
<p><strong>核心处理层:</strong> </p>
<p>接下来是核心处理层。 既然叫核心处理层， 也就是跟数据库操作相关的动作都是在这层完成的。<br>核心处理层主要做了这几件事：</p>
<ol>
<li>把接口中传入的参数解析并且映射成 JDBC 类型；<br>.    解析 xml 文件中的SQL语句， 包括插入参数， 和动态SQL的生成；<br>.    执行SQL语句，<br>.    处理结果集， 并映射成 Java 对象。</li>
</ol>
<p>插件也属于核心层， 这是由它的工作方式和拦截的对象决定的。</p>
<p><strong>基础支持层:</strong> </p>
<p>基础支持层主要是一些抽取出来的通用的功能（实现复用）， 用来支持核心处理层的功能。 比如数据源,缓存,日志,xml 解析,反射,IO,事务等等这些功能。</p>
<p><strong>MyBatis缓存:</strong></p>
<ul>
<li>cache缓存:</li>
</ul>
<p>缓存是—般的ORM框架都会提供的功能，目的就是提升查询的效率和减少数据库的压力。跟Hibernate一样，MyBatis也有一级缓存和二级缓存，并且预留了集成第三方,缓存的接口。</p>
<ul>
<li>缓存体系结构:</li>
</ul>
<p>MyBatis 跟缓存相关的类都在 cache 包里面，其中有一个 Cache 接口， 只有一个默认的实现类 PerpetualCache, 它是用 HashMap 实现的。</p>
<p>PerpetualCache这个对象一定会创建，所以这个叫做基础缓存。但是缓存又可以有很多额外的功能， 比如回收策略、 日志记录、 定时刷新等等， 如果需要的话， 就可以给基础缓存加上这些功能， 如果不需要， 就不加。</p>
<p>除了基础缓存之外， MyBatis 也定义了很多的装饰器， 同样实现了 Cache 接口， 通过这些装饰器可以额外实现很多的功能。 </p>
<p>装饰者模式(Decorator Pattern) 是指在不改变原有对象的基础之上， 将功能附加到对象上， 提供了比继承更有弹性的替代方案（扩展原有对象的功能）。 </p>
<p><img src="https://i.loli.net/2020/05/14/7yM8NuCoaf4VeFr.png" alt="image.png"></p>
<p>debugi原码的时候， 有可能会看到基础缓存被装饰四五层， 当然不管怎么装饰， 经过多少层装饰，最后使用的还是基本的实现类（默认PerpetualCache)。在CachingExecutor中的query()方法,需要在mapper.xml配置<strong>*<cache>*</strong>标签</p>
<p><img src="https://i.loli.net/2020/05/14/TRa7XLzde38MpSk.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/14/wSPpiACEflLh5eu.png" alt="image.png"></p>
<p>所有的缓存实现类总体上可分为三类：基本缓存、 淘汰算法缓存、 装饰器缓存。</p>
<p><img src="https://i.loli.net/2020/05/14/AhDHUsw7QvVm1YL.png" alt="image.png"></p>
<ul>
<li><p>—级缓存（本地缓存）</p>
<p>一级缓存也叫本地缓存(Local Cache), MyBatis的一级缓存是在会话(SqlSession)层面进行缓 存的。 MyBatis 的一级缓存 是默认开启的， 不需要任何的配置,localCacheScope设置为STATEMENT关闭一级缓存）。</p>
<p>BaseExecutor的query()</p>
<p>if (configuration.getLocalCacheScope() == LocalCacheScope.STATEl\1ENT) {</p>
<p>​    clear Local Cache(); </p>
<p>}</p>
<pre><code>首先我们必须去弄清楚一个问题， 在MyBatis执行的流程里面，涉及到这么多的对象，那么缓存 PerpetualCache应该放在哪个对象里面去维护？</code></pre><p>​    如果要在同一个会话里面共享一级缓存 ，最好的办法是在SqlSession里面创建的，作为SqlSession的一个属性，跟SqlSession 共存亡，这样就不需要为SqlSession 编号,再根据SqlSession的编号去查找对应的缓存了。</p>
<p>​    查看源码SqlSession的默认实现中DefaultSqlSession里面只有两个对象 属性：Configuration和Executor。</p>
<p><img src="https://i.loli.net/2020/05/14/xYLMV9dUvbh7atp.png" alt="image.png"></p>
<p>​    Configuration是全局的，不属于SqISession,所以缓存只可能放在Executor里面维护——实际上它是在基本执行器SimpleExecutor/ReuseExecutor/BatchExecutor的父类BaseExecutor的构造函数中持有了PerpetualCache。</p>
<p><img src="https://i.loli.net/2020/05/14/jaRmVoLrlYFIUxW.png" alt="image.png"></p>
<p>​    在同一个会话里面， 多次执行 相同的SQL语句， 会直接从内存取到缓存的结果，不会再发送SQL到数据库。 但是不同的会话里面，即使执行的SQL一模一样（通过一个Mapper的同一个方法的相同参数调用），也不能使用到一级缓存.</p>
<p><img src="https://i.loli.net/2020/05/14/phqkwdlT5cWM29G.png" alt="image.png"></p>
</li>
</ul>
<p>接下来我们来验证一下， MyBatis 的一级缓存到底是不是只能在一个会话里面共享，以及跨会话（不同 session) 操作相同的数据会产生什么问题。</p>
<p>—级缓存验证</p>
<p>注意一级缓存需要先关闭二级缓存，localCacheScope设置为SESSION。怎么判断是否命中缓存？如果再次发送SQL到数据库执行（控制台打印了SQL语句）， 说明没有命中缓存；如果直接打印对象， 说明是从内存缓存中取到了结果。</p>
<p>1 、 在同一个 session 中共享</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);</span><br><span class="line">System.out.println(mapper. selectBlog(l)); </span><br><span class="line">System.out.println(mapper. selectBlog(l));</span><br></pre></td></tr></table></figure>

<p>2、不同 session 不能共享</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SqlSession sessionl &#x3D; sqlSessionFactory.openSession(); </span><br><span class="line">BlogMapper mapperl &#x3D; sessionl.getMapper(BlogMapper.class); </span><br><span class="line">System.out.println(mapper. selectBlog(l));</span><br></pre></td></tr></table></figure>

<p>PS: </p>
<p>一级缓存在 BaseExecutor 的 query()的queryFromDatabase(）中存入。在queryFromDatabase之前会get(）。</p>
<p><img src="https://i.loli.net/2020/05/14/45UJubm9tvCAdqS.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/05/14/f9bjRrs4561XmLN.png" alt="image.png"></p>
<ol start="3">
<li>一级缓存在什么时候put,什么时候get,什么时候clear?</li>
</ol>
<p>Base Executor的queryFromDatabase()</p>
<ol start="4">
<li>一级缓存怎么命中？CacheKey怎么构成？</li>
</ol>
<p><img src="https://i.loli.net/2020/05/14/PURivulCLzjGepa.png" alt="image.png"></p>
<ol start="5">
<li><p>一级缓存什么时候 会被清空呢？</p>
<p>同一个会话中， update（包括delete)会导致一级缓存被清空</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapper.updateByPrimaryKey(blog); </span><br><span class="line">session.commit(); </span><br><span class="line">System.out.println(mapper.selectBlogByld(l));</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>问题：只有更新会清空缓存吗？查询会清空缓存吗？如果要清空呢？</li>
</ol>
<p>一级缓存是在BaseExecutor中的update(）方法中调用clearlocalCache(）清空的,(无条件） 如果是query 会判断（只有 select标签的flushCache=true才清空）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BaseExecutor implements Executor &#123;</span><br><span class="line">    protected PerpetualCache localCache;</span><br><span class="line">    @Override</span><br><span class="line">      public int update(MappedStatement ms, Object parameter) throws SQLException &#123;</span><br><span class="line">        ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing an update&quot;).object(ms.getId());</span><br><span class="line">        if (closed) &#123;</span><br><span class="line">          throw new ExecutorException(&quot;Executor was closed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        clearLocalCache();</span><br><span class="line">        return doUpdate(ms, parameter);</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void clearLocalCache() &#123;</span><br><span class="line">        if (!closed) &#123;</span><br><span class="line">          localCache.clear();</span><br><span class="line">          localOutputParameterCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li><p>一级缓存的工作范围是一个会话。 如果跨会话， 会出现什么问题？</p>
<p>其他会话更新了数据， 导致读取到过时的数据(—级缓存不能跨会话共享）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//会话2更新了数据，会话2的一级缓存更新</span></span><br><span class="line">BlogMapper mapper2 = session2.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; </span><br><span class="line">mapper2.updateByPrimaryKey(blog); </span><br><span class="line">session2. commit(); </span><br><span class="line"><span class="comment">//会话 1 读取到过时的数据， 因为一级缓存不能跨会话共享</span></span><br><span class="line">System.out.println(mapper1.selectBlog(l));</span><br></pre></td></tr></table></figure>



<ul>
<li><p>—级缓存的不足</p>
<p>使用一级缓存的时候， 因为缓存不能跨会话共享， 不同的会话之间对于相同的数据,可能有不一样的缓存。 在有多个会话或者分布式环境下， 会存在查到过时数据的问题。如果要解决这个问题， 就要用到工作范围更广的二级缓存。</p>
</li>
</ul>
<ul>
<li><p>二级缓存</p>
<p>二级缓存是用来解决一级缓存不能跨会话共享的问题的， 范围是 namespace级别的， 可以被多个SqlSession共享（只要是同一个接口里面的相同方法， 都可以共享），生命周期和应用同步。</p>
<p>思考一个问题：如果开启了二级缓存， 二级缓存应该是工作在级缓存之前， 还是在一级缓存之后呢？二级缓存是在哪里维护的呢？</p>
<p>作为一个作用范围更广的缓存， 它肯定是在SqlSession的外层， 否则不可能被多个SqlSession共享。</p>
<p>而一级缓存是在SqlSession内部的，<strong><em>所以第一个问题，肯定是工作在一级缓存之前，也就是只有取不到二级缓存的情况下才到一个会话中去取一级缓存。</em></strong></p>
<p>第二个问题二级缓存放在哪 个对象中维护呢？ 要跨会话共享的话，SqlSession本身和它里面的BaseExecutor已经满足不了需求了，那我们应该在BaseExecutor 之外创建一个对象。</p>
<p>但是， 二级缓存是不一定开启的。 也就是说， 开启了二级缓存， 就启用这个对象，如果没有， 就不用这个对象， 我们应该怎么做呢？就好像你的煎饼果子要加鸡蛋就加鸡蛋， 要加火腿就加火腿（又来了）……</p>
<p>实际上MyBatis用了一个装饰器的类来维护， 就是Caching Executor。 如果启用了二级缓存， MyBatis在创建 Executor 对象的时候会对 Executor 进行装饰。</p>
<p>CachingExecutor对于查询请求，会判断二级缓存是否有缓存结果，如果有就直接返回，如果没有委派交给真正的查询器Executor实现类，比如SimpleExecutor来执行查询， 再走到一级缓存的流程。 最后会把结果缓存起来， 并且返回给用户。</p>
<p><img src="https://i.loli.net/2020/05/14/LjSQo6UViwmlBgM.png" alt="image.png"></p>
</li>
</ul>
<p>我们知道，一级缓存是默认开启的， 那二级缓存怎么开启呢？我们来看下二级缓存的开启方式。</p>
<p>开启二级缓存的方法</p>
<p>第一步：在 mybatis-config.xml 中配置了（可以不配置， 默认是 true)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>只要没有显式地设置 cacheEnabled =false, 都会用 CachingExecutor 装饰基本的执行器(SIMPLE,REUSE,BATCH)。</p>
<p>二级缓存的总开关是默认开启的。但是每个Mapper的二级缓存开关是默认关闭的。</p>
<p>一个Mapper要用到二级缓存， 还要单独打开它自己的开关。</p>
<p>第二步：在Mapper.xml中配置&lt;cache/＞标签：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">＜！－－ 声明这个 namespace 使用二级缓存 －－＞</span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.cache.impl.PerpetualCache"</span>&gt;</span></span><br><span class="line">    size="1024"  <span class="tag">&lt;<span class="name">!—最多缓存对象个数，</span> 默认 <span class="attr">1024--</span>&gt;</span></span><br><span class="line">    eviction="LRU" <span class="tag">&lt;<span class="name">!—回收策略－－＞</span></span></span><br><span class="line">    flushlnterval="120000"&lt;！—自动刷新时间 ms, 未配置时只有调用时刷新－－＞</span><br><span class="line">    readOnly="false"/＞<span class="tag">&lt;<span class="name">!—默认是</span> <span class="attr">false</span> （安全）， 改为 <span class="attr">true</span> 可读写时， 对象必须支持序列化 －－＞</span></span><br><span class="line">&lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>cache属性详解：</p>
<p><img src="https://i.loli.net/2020/05/14/vtUAfYdghJNkMR2.png" alt="image.png"></p>
</li>
</ul>
<p>Mapper.xml配置了<cache>之后，select()会被缓存。update(）、delete(）、insert()会刷新缓存。</p>
<p>如果二级缓存拿到结果了， 就直接返回（最外层的判断）， 否则再到一级缓存， 最后到数据库。</p>
<p>如果设置了 cacheEnabled=true, Mapper.xml没有配置<cache>标签还有二级缓存吗？还会出现CachingExecutor包装对象吗？</p>
<p>只要cacheEnabled =true基本执行器就会被装饰。有没有配置<cache>，决定了在启动的时候会不会创建这个mapper的Cache对象，最终会影响到CachingExecutor中query方法里面的判断：</p>
<p><img src="https://i.loli.net/2020/05/14/FjuyEcahCKk2dNJ.png" alt="image.png"></p>
<p>也就是说， 此时会装饰， 但是没有 cache对象， 依然不会走二级缓存流程。</p>
<p>如果一个Mapper需要开启二级缓存， 但是这个里面的某些查询方法对数据的实时性要求很高， 不需要二级缓存， 怎么办？</p>
<p>我们可以在单个StatementID上显式关闭 二级缓存（useCache默认是true),</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">useCache</span>=<span class="string">"false"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CachingExecutor query方法有对这个属性的判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="comment">// 获取二级缓存</span></span><br><span class="line">        <span class="comment">// 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          <span class="comment">// 写入二级缓存</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>二级缓存验证</p>
<p>(验证二级缓存需要先开启二级缓存）</p>
<ol>
<li>事务不提交， 二级缓存不存在</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlogMapper mapperl = sessionl.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out. println(mapper <span class="number">1</span>. selectBlogByld(l)); </span><br><span class="line"><span class="comment">//事务不提交的情况下， 二级缓存不会写入</span></span><br><span class="line"><span class="comment">//session1.commit(); </span></span><br><span class="line">session1.commit(); </span><br><span class="line">BlogMapper mapper2 = session2.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>; System.out.println(mapper2.selectBlogByld(l));</span><br></pre></td></tr></table></figure>

<p>思考：为什么事务 不提交，二级缓存不生效？</p>
<p>因为二级缓存使用 TransactionalCacheManager (TCM)来管理， 最后又调用了TransactionaICache的getObject(）、putObject 和 commit(）方法，TransactionaICache 里面又持有了真正的Cache对象，比如是经过层层装饰的PerpetualCache。</p>
<p>在putObject的时候， 只是添加到了 entriesToAddOnCommit里面， 只有它的commit(）方法被调用的时候才会调用 flushPendingEntries(）真正写入缓存。 它就是在DefaultSqlSession调用 commit(）的时候被调用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor delegate;</span><br><span class="line">  <span class="comment">//事务对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransactionalCacheManager tcm = <span class="keyword">new</span> TransactionalCacheManager();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务管理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    Object object = getTransactionalCache(cache).getObject(key);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalCaches.computeIfAbsent(cache, TransactionalCache::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">     <span class="comment">//这是一个待提交的缓存Map</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">        entriesToAddOnCommit.put(key, object);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正写入二级缓存</span></span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushPendingEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : entriesToAddOnCommit.entrySet()) &#123;</span><br><span class="line">      delegate.putObject(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Object entry : entriesMissedInCache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!entriesToAddOnCommit.containsKey(entry)) &#123;</span><br><span class="line">        delegate.putObject(entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/14/SEo91RCwsim3UHZ.png" alt="image.png"></p>
<ol start="2">
<li>使用 不同的session和mapper，并且提交事务，验证二级缓存可以跨session存在</li>
</ol>
<p>取消以上代码commit(）的注释， 测试。</p>
<ol start="3">
<li><p>在其他的session中执行增删改操作， 验证缓存会 被刷新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog = <span class="keyword">new</span> Blog(); </span><br><span class="line">blog.setBid(l); </span><br><span class="line">blog.setName(<span class="string">''</span><span class="number">357</span><span class="string">''</span>); </span><br><span class="line">mapper3. updateByPrimaryKey(blog); </span><br><span class="line">session3. commit(); </span><br><span class="line"><span class="comment">//执行了更新操作， 二级缓存失效， 再次发送 SQL 查询</span></span><br><span class="line">System.out.println(mapper2.selectBlogByld(l));</span><br></pre></td></tr></table></figure>

<p>为什么增删改操作会清空缓存？</p>
<p>在 Caching Executor 的 update(）方法里面会调用 flushCachelfRequired(ms),</p>
<p>isFlushCacheRequired 就是从标签里面渠道的 flushCache 的值。 而增删改操作的flushCache 属性默认为 true。</p>
<p>也就是说， 如果不需要清空二级缓存， 可以把 flushCache 属性修改为 false （这样会造成过时数据的问题）。</p>
<p>什么时候开启二级缓存？</p>
<p>一级缓存默认是打开的， 二级缓存需要配置才可以开启。 那么我们必须思考一个问题， 在什么情况下才有必要去开启二级缓存？</p>
<p>​    1、 因为所有的增删改都会刷新二级缓存， 导致二级缓存失效， 所以适合在查询为主的应用中使用， 比如历史交易、 历史订单的查询。 否则缓存就失去了意义。</p>
<p>​         2、如果多个 namespace 中有针对于同一个表的操作， 比如 Blog 表， 如果在一个namespace 中刷新了缓存， 另一个 namespace 中没有刷新， 就会出现读到脏数据的情</p>
<p>所以， 推荐在一个 Mapper 里面只操作单表的情况使用。</p>
<p>如果要让多个 namespace 共享一个二级缓存， 应该怎么做？</p>
<p>跨 namespace 的缓存共享的问题， 可以使用<cache-ref> 来解决：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">" com.gupaoedu.crud.dao.DepartmentMapper"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>cache-ref 代表引用别的命名空间的 Cache 配置， 两个命名空间的操作使用的是同一个Cache。在关联的表比较少，或者按照业务可以对表进行分组的时候可以使用。</p>
<p>注意： 在这种情况下，多个Mapper的操作都会引起缓存刷新，缓存的意义已经不大了。</p>
</li>
<li><p>第三方缓存做二级缓存</p>
<p>除了MyBatis自带的二级缓存之外，我们也可以通过实现Cache接口来自定义二级缓存</p>
<p>MyBatis官方提供了一些第三方缓存集成方式，比如ehcache和redis : </p>
<p><a href="https://g" target="_blank" rel="noopener">https://g</a> ithu b.com/mybatis/redis-cache </p>
<p>porn文件引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/ <span class="attr">groupld</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>mybatis-redis<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 1.0.O-beta2 <span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Mapper.xml配置，type使用RedisCache :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.redis.RedisCache"</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flush</span>血<span class="attr">erval</span>=<span class="string">"60000"</span> <span class="attr">size</span>=<span class="string">"512"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>red is.properties配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">host</span>=<span class="string">localhost </span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379 </span></span><br><span class="line"><span class="attr">connectionTimeout</span>=<span class="string">5000 </span></span><br><span class="line"><span class="attr">soTimeout</span>=<span class="string">5000 </span></span><br><span class="line"><span class="attr">database</span>=<span class="string">O</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>工作流程</tag>
        <tag>缓冲原理</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis插件原理</title>
    <url>/gxblog/2020/06/25/4.MyBatis%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="MyBatis插件原理"><a href="#MyBatis插件原理" class="headerlink" title="MyBatis插件原理"></a>MyBatis插件原理</h1><h3 id="MyBatis插件原理与自定义插件"><a href="#MyBatis插件原理与自定义插件" class="headerlink" title="MyBatis插件原理与自定义插件"></a>MyBatis插件原理与自定义插件</h3><h5 id="1-插件的使用"><a href="#1-插件的使用" class="headerlink" title="1.插件的使用"></a>1.插件的使用</h5><p>运行自定义的插件，需要3步，我们以PageHelper为例：</p>
<p>插件编写,编写拦截器类，需要做的有三点</p>
<p>①.实现Interceptor接口</p>
<p>②.实现相应的方法。最关键的是intercept(）方法里面是拦截的逻辑， 需要增强的功能代码就写在这里。</p>
<p>③.在拦截器类加上注解@Intercepts。注解签名指定了需要拦截的对象、拦截的方法、参数（因为方法有不同的重载， 所以要指定具体的参数）。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>, args = &#123; MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">RowBounds</span>.<span class="title">class</span>, <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最关键的是intercept方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//plugin获取代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置配置&lt;plugins&gt;中标签的属性设置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-插件配置"><a href="#2-插件配置" class="headerlink" title="2.插件配置"></a>2.插件配置</h5><p>在mybatis-config.xml中注册插件，配置属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.gxedu.interceptor.TableInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"offsetAsPageNum"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rowBoundsWithCount"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pageSizeZero"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"reasonable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"params"</span> <span class="attr">value</span>=<span class="string">"pageNum=start;pageSize=limit; "</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportMethodsArguments"</span> <span class="attr">value</span>= <span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retumPagelnfo"</span> <span class="attr">value</span>=<span class="string">"check"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>插件解析注册</p>
<p>MyBatis启 动时扫描<plugins>标签， 注册到Configuration对象的lnterceptorChain中。property里面的参数，会调用setProperties(）方法处理。</p>
<p>在启动解析的时候，把所有的插件全部存到了Configuration的lnterceptorChain中，它是一个List。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      <span class="comment">//完成第一步插件的配置的解析工作</span></span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//解析插件,获取每一个&lt;interceptor&gt;标签变成一个Interceptor拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        <span class="comment">//添加到configuration中</span></span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拦截器链,存放我们定义的拦截器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    	interceptorChain.addInterceptor(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//调用	addInterceptor()方法,添加到List&lt;Interceptor&gt; interceptors中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h6><p>MyBatis的插件不用修改原jar包的代码，就可以改变核心对象的行为，比如在前面处理参数，在中间处理 SQL, 在最后处理结果集。</p>
<ul>
<li><p>不修改代码怎么增强功能？</p>
<p>不修改对象的代码， 怎么对对象的行为进行修改，比如说在原来的方法前面做一点事情， 在原来的方法后面做一点事情？</p>
<p>很容易能想到用代理模式， 这个也确实是 M-yBatis 插件的实现原理。</p>
</li>
<li><p>多个插件怎么拦截？</p>
<p>我们可以定义很多的插件， 那么这种所有的插件会形成一个链路，执行完了第一个插件的逻辑， 要继续执行第二个第三个插件的逻辑。</p>
<p>比如我们提交一个休假申请， 先是项目经理审批， 然后是部门经理审批， 再是 HR审批， 再到总经理审批， 怎么实现层层的拦截？如果是代理模式， 已经被代理过的对象，可以再次被代理吗？</p>
<p>答案：插件是层层拦截的， 我们又需要用到另一种设计模式——责任链模式。</p>
</li>
<li><p>什么对象可以被拦截？</p>
<p>如果是用代理模式， 我们就要解决几个问题：</p>
<p>1 、有哪些对象允许被代理？有哪些方法可以被拦截？</p>
<p>并不是每一个运行的节点都是可以被修改的（如果没有这种规范， 就会造成混乱和带来风险）。 只有清楚了这些对象的方法的作用， 当我们自己编写插件的时候才知道从哪里去拦截。</p>
<p><img src="https://i.loli.net/2020/05/16/nuWjF74P19ZmV56.png" alt="image.png"></p>
<p>这里需要注意的是， 因为 Executor 有可能被二级缓存装饰， 那么是先代理再装饰，还是先装饰后代理呢？</p>
<p>Executor 会拦截到 CachingExcecutor 或者 BaseExecutor。</p>
<p>DefaultSqlSessionFactory.openSessionFromDataSource() </p>
<p>先创建基本类型SimpleExecutor， 再二级缓存装饰CachingExecutor， 最后插件拦截interceptorChain.pluginAll(executor)。 所以这里拦截的是Caching Executor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*ExecutorType.BATCH</span></span><br><span class="line"><span class="comment">    配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）；</span></span><br><span class="line"><span class="comment">    BATCH 执行器不仅重用语句还会执行批量更新。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(); <span class="comment">//  ExecutorType.BATCH</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String str = <span class="string">"2020-02-26"</span>;</span><br><span class="line">        SimpleDateFormat sm = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Fee fee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fee = <span class="keyword">new</span> Fee (sm.parse (str));</span><br><span class="line">            FeeMapper mapper = session.getMapper(FeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;Fee&gt; list = mapper.selectByFeeDate(fee);</span><br><span class="line">            session.commit ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, 				TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">        Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">          <span class="comment">// 获取事务工厂</span></span><br><span class="line">          <span class="keyword">final</span> TransactionFactory transactionFactory =                         							getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">          <span class="comment">// 创建事务</span></span><br><span class="line">          tx = transactionFactory.newTransaction(environment.getDataSource(), level, 					autoCommit);</span><br><span class="line">          <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">          <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">          <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">        Executor executor;</span><br><span class="line">        <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">          executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">        <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">            <span class="comment">//如果开启缓冲对,二级缓冲的包装成CachingExecutor</span></span><br><span class="line">          executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">        executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-插件实现原理"><a href="#3-插件实现原理" class="headerlink" title="3.插件实现原理"></a>3.插件实现原理</h5><p>如果是代理模式， 又有几个问题需要解决：</p>
<p>1 、 代理类怎么创建？动态代理是 JDK Proxy 还是 Cglib？怎么样创建代理？</p>
<p>2、 代理类在什么时候创建？是在解析配置的时候创建， 还是获取会话的时候创建，还是在调用的时候创建？</p>
<p>3、 核心对象被代理之后， 调用的流程是怎么样的？怎么依次执行多个插件的逻辑？在执行完了插件的逻辑之后， 怎么执行原来的逻辑？</p>
<p>只要理解了代理模式在这里的运用， 就理解了插件的工作流程。</p>
<p>代理类什么时候创建？</p>
<p>对Executor拦截的代理类是openSession(）的时候创建的。</p>
<p>Configuration.newExecutor() </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//调用openSessionFromDataSource()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 创建事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;	 </span><br><span class="line"><span class="comment">//调用configuration.newExecutor(tx, execType)创建执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>StatementHandler是SimpleExecutor.doQuery(）创建的；里面包含了ParameterHandler和ResultSetHandler的创建和代理。以及如果使用插件进行拦截.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="comment">// 获取一个 Statement对象</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">// 执行查询</span></span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 用完就关闭</span></span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, 				parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType="PREPARED"，默认值 PREPARED</span></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="comment">//Statement 每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.</span></span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        <span class="comment">// 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span></span><br><span class="line">        <span class="comment">//PreparedStatement是预编译的</span></span><br><span class="line">        <span class="comment">//a. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。</span></span><br><span class="line">        <span class="comment">// b. 安全性好，有效防止Sql注入等问题。</span></span><br><span class="line">        <span class="comment">// c.  对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；</span></span><br><span class="line">        <span class="comment">// d.  代码的可读性和可维护性。</span></span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。</span></span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PreparedStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了四大对象的其它两大对象 &gt;&gt;</span></span><br><span class="line">    <span class="comment">// 创建这两大对象的时候分别做了什么？</span></span><br><span class="line">    <span class="comment">//ParameterHandler参数处理</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">//ResultSetHandler结果集处理</span></span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代理怎么创建？</p>
<p>调用lnterceptorChain的pluginAII(）方法，做了什么事？</p>
<p>遍历lnterceptorChain，使用Interceptor实现类的plugin(）方法，对目标核心对象进行代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历拦截器链,代理+包装创建代理对象</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">        <span class="comment">//调用interceptor.plugin()创建代理对象</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 plugin 方法是我们自己实现的， 要返回一个代理对象。</p>
<p>如果是JDK动态代理，那我们必须要写 一个实现了lnvocationHandler接口的触发管理类。 然后用 Proxy.newProxylnstance(）创建一个代理对象。</p>
<p>Mybatis 的插件机制已经把这些类封装好了，它已经提供了一个触发管理类 Plugin, 实现了 lnvocationHandler。</p>
<p>创建代理对象的newProxylnstance(）在这个类里面也进行了封装，就是wrap(）方法。</p>
<p>在 wrap 的时候创建了一个 Plugin 对象， Plugin 是被代理对象、 Interceptor 的一个封装对象：</p>
<p>new Plugin(target, interceptor, signatureMap)</p>
<p>持有了被代理对象和interceptor的实例：</p>
<p>因为这里是 for 循环代理，所以某个核心对象有多个插件，会返回被代理多次的代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义插件,在调用interceptor.plugin(target)方法,会调用自定义插件的plugin()方法</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>, args = &#123; MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">RowBounds</span>.<span class="title">class</span>, <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Plugin.warp()创建代理对象,因为我们的Plugin对象默认实现了InvocationHandler接口</span></span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Proxy.newProxyInstance()的jdk动态代理创建代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了InvocationHandler的默认需要重写invoke()方法,会先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; 																			signatureMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的目标对象</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//执行的拦截器</span></span><br><span class="line">        <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">        <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>被代理之后， 调用的流程？</p>
<p>在四大核心对象的一次执行过程中（可能被代理多次）， 因为已经被代理了， 所以会先走到触发管理类Plugin的invoke(）方法。</p>
<p>如果被拦截的方法不为空，进入Plugin的invoke(）方法，调用interceptor的intercept(）方法：</p>
<p>到了 intercept(）方法，也就走到了我们自己实现的拦截逻辑（例如 Pagelnterceptor 的intercept(）方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">          <span class="comment">//调用interceptor的intercept(）方法实现自定义拦截</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意参数是new出来的Invocation对象(new Invocation(target, method, args))，它是对被拦截对象、被拦截方法、被拦截参数的一个封装。 为什么要传这样一个参数呢？</p>
<p>当然， 在代理逻辑执行完了之后， 比如继续执行被代理对象（四大核心对象）的原方法， 也就是说要有一行这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br></pre></td></tr></table></figure>

<p>或者拿到被代理的核心对象， 继续执行它的方法（比如 executor.query()) 。这个时候， 我们要拿到被代理对象和它的参数， 去哪里拿？</p>
<p>就是上面创建的 Invocation 对象。 它简化了参数的传递， 而且直接提供了一个proceed(）方法， 也就是说继续执行原方法可以写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Invocation</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object[] getArgs() &#123;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//直接调用proceed()方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/16/WMEpLf4c5kJnZNw.png" alt="image.png"></p>
<p>如果说对象被代理了多次， 这里会继续调用下一个插件的逻辑， 再走一次 Plugin 的invoke(）方法。 这里我们需要关注一下有多个插件的时候的运行顺序。</p>
<ul>
<li>配置的顺序和执行的顺序？</li>
</ul>
<p>配置的顺序和执行的顺序是相反的。lnterceptorChain的List是按照插件从上往下的顺序解析、 添加的。</p>
<p>而创建代理的时候也是按照Iist的顺序代理。执行的时候当然是从最后代理的对象开始。</p>
<p><img src="https://i.loli.net/2020/05/16/gpdBkWHyZqmAnFV.png" alt="image.png"></p>
<h5 id="4、PageHelper原理"><a href="#4、PageHelper原理" class="headerlink" title="4、PageHelper原理"></a>4、PageHelper原理</h5><ul>
<li><p>逻辑翻页</p>
<p>使用RowBounds翻页 ， 在内存中筛选数据。</p>
<p>使用和参数传递</p>
<p>在引入了 pageHelper 的依赖， 配置了插件之后， 如果我们需要翻页， 需要用到相关的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(pn, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>在 PageHelper 类中指定页码和每页数量。 MyBatis 的方法不用做任何的修改， 最后可以把结果包装成一个 Pagelnfo 返回给前端。</p>
<p>如果不需要翻页， 把这两行代码去掉就行了。 插件的优点就是不用修改 MyBatis 本身的代码。</p>
</li>
<li><p>SQL改写的实现</p>
<p>PageHelper到底是怎么通过拦截实现翻页的呢？</p>
<p>首先看一下拦截器，Pagelnterceptor类。</p>
<p>首先判断是否需要 count 获取总数，默认是 true。获得 count 之后， 判断是否需要分页， 如果 pageSize&gt;O, 就分页。</p>
<p>这里通过 getPageSql()方法生成了一个新的 BoundSql:</p>
<p>getPageSql()对于不同的数据库有不同的实现：</p>
<p><img src="https://i.loli.net/2020/05/17/MUOENaqnjs6olIK.png" alt="image.png"></p>
<p>以MySQL为例， 实际上是添加了LIMIT语句， 加上了起始位置和结束位置：</p>
<p>问题是， 插件是怎么获取到页码和每页数量， 是怎么传递给插件的？</p>
<p>回头看看PageHelper.startPage(）方法， startPage(）调用了PageMethod的setlocalPage(）方法， 包装了一个Page对象， 并且把这个对象放到了ThreadLocal变量中。</p>
<p>而在AbstractHelperDialect中 ， Page对象中的翻页信息是通过getlocalPage()取出来的：</p>
<p>它调用的正是PageHelper的getlocalPage(）, 从ThreadLocal中获取到了翻页信息</p>
<p>所以， 每次查询（每 —个线程）都会有 —个线程私有的Page对象 ， 它里面有页码和每页数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Page&lt;E&gt; <span class="title">startPage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize, <span class="keyword">boolean</span> count)</span> </span>&#123;</span><br><span class="line">        Page&lt;E&gt; page = <span class="keyword">new</span> Page(pageNum, pageSize, count);</span><br><span class="line">        setLocalPage(page);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelperDialect</span> <span class="keyword">extends</span> <span class="title">AbstractDialect</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, Object 							parameterObject, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        <span class="comment">//从ThreadLocal中获取分页的设置的起始页,以及每页显示的条数</span></span><br><span class="line">        Page page = <span class="keyword">this</span>.getLocalPage();</span><br><span class="line">        <span class="comment">//getPageSql()获取不同数据库厂商的分页关键字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPageSql(sql, page, pageKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从ThreadLoacl中获取分页参数</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PageHelper.getLocalPage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Page)LOCAL_PAGE.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/17/91EYKjsvUxzy4Xa.png" alt="image.png"></p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cache&lt;CacheKey, MappedStatement&gt; msCountMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Dialect dialect;</span><br><span class="line">    <span class="keyword">private</span> String default_dialect_class = <span class="string">"com.github.pagehelper.PageHelper"</span>;</span><br><span class="line">    <span class="keyword">private</span> Field additionalParametersField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object var22;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = invocation.getArgs();</span><br><span class="line">            MappedStatement ms = (MappedStatement)args[<span class="number">0</span>];</span><br><span class="line">            Object parameter = args[<span class="number">1</span>];</span><br><span class="line">            RowBounds rowBounds = (RowBounds)args[<span class="number">2</span>];</span><br><span class="line">            ResultHandler resultHandler = (ResultHandler)args[<span class="number">3</span>];</span><br><span class="line">            Executor executor = (Executor)invocation.getTarget();</span><br><span class="line">            CacheKey cacheKey;</span><br><span class="line">            <span class="comment">//原生的sql语句</span></span><br><span class="line">            BoundSql boundSql;</span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">4</span>) &#123;</span><br><span class="line">                boundSql = ms.getBoundSql(parameter);</span><br><span class="line">                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cacheKey = (CacheKey)args[<span class="number">4</span>];</span><br><span class="line">                boundSql = (BoundSql)args[<span class="number">5</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List resultList;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dialect.skip(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; additionalParameters = (Map)<span class="keyword">this</span>.additionalParametersField.get(boundSql);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.dialect.beforeCount(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    CacheKey countKey = executor.createCacheKey(ms, parameter, RowBounds.DEFAULT, boundSql);</span><br><span class="line">                    countKey.update(<span class="string">"_Count"</span>);</span><br><span class="line">                    MappedStatement countMs = (MappedStatement)<span class="keyword">this</span>.msCountMap.get(countKey);</span><br><span class="line">                    <span class="keyword">if</span> (countMs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        countMs = MSUtils.newCountMappedStatement(ms);</span><br><span class="line">                        <span class="keyword">this</span>.msCountMap.put(countKey, countMs);</span><br><span class="line">                    &#125;</span><br><span class="line">				</span><br><span class="line">                    String countSql = <span class="keyword">this</span>.dialect.getCountSql(ms, boundSql, parameter, rowBounds, countKey);</span><br><span class="line">                    BoundSql countBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(), parameter);</span><br><span class="line">                    Iterator var16 = additionalParameters.keySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var16.hasNext()) &#123;</span><br><span class="line">                        String key = (String)var16.next();</span><br><span class="line">                        countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object countResultList = executor.query(countMs, parameter, RowBounds.DEFAULT, resultHandler, countKey, countBoundSql);</span><br><span class="line">                    Long count = (Long)((List)countResultList).get(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.dialect.afterCount(count, parameter, rowBounds)) &#123;</span><br><span class="line">                        Object var18 = <span class="keyword">this</span>.dialect.afterPage(<span class="keyword">new</span> ArrayList(), parameter, rowBounds);</span><br><span class="line">                        <span class="keyword">return</span> var18;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.dialect.beforePage(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, boundSql);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter = <span class="keyword">this</span>.dialect.processParameterObject(ms, parameter, boundSql, cacheKey);</span><br><span class="line">                    	<span class="comment">//重新生成新的带分页参数的sql语句</span></span><br><span class="line">                    String pageSql = <span class="keyword">this</span>.dialect.getPageSql(ms, boundSql, parameter, rowBounds, cacheKey);</span><br><span class="line">                    BoundSql pageBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), pageSql, boundSql.getParameterMappings(), parameter);</span><br><span class="line">                    Iterator var25 = additionalParameters.keySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!var25.hasNext()) &#123;</span><br><span class="line">                            resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, pageBoundSql);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String key = (String)var25.next();</span><br><span class="line">                        pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var22 = <span class="keyword">this</span>.dialect.afterPage(resultList, parameter, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.dialect.afterAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var22;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelperDialect</span> <span class="keyword">extends</span> <span class="title">AbstractDialect</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, Object 							parameterObject, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        <span class="comment">//从ThreadLocal中获取分页的设置的起始页,以及每页显示的条数</span></span><br><span class="line">        Page page = <span class="keyword">this</span>.getLocalPage();</span><br><span class="line">        <span class="comment">//getPageSql()获取不同数据库厂商的分页关键字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPageSql(sql, page, pageKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//Mysqy的数据库厂商</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlDialect</span> <span class="keyword">extends</span> <span class="title">AbstractHelperDialect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySqlDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(String sql, Page page, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        StringBuilder sqlBuilder = <span class="keyword">new</span> StringBuilder(sql.length() + <span class="number">14</span>);</span><br><span class="line">        sqlBuilder.append(sql);</span><br><span class="line">        <span class="keyword">if</span> (page.getStartRow() == <span class="number">0</span>) &#123;</span><br><span class="line">            sqlBuilder.append(<span class="string">" LIMIT "</span>);</span><br><span class="line">            sqlBuilder.append(page.getPageSize());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sqlBuilder.append(<span class="string">" LIMIT "</span>);</span><br><span class="line">            sqlBuilder.append(page.getStartRow());</span><br><span class="line">            sqlBuilder.append(<span class="string">","</span>);</span><br><span class="line">            sqlBuilder.append(page.getPageSize());</span><br><span class="line">            pageKey.update(page.getStartRow());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pageKey.update(page.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> sqlBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>插件原理，拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis与Spring整合</title>
    <url>/gxblog/2020/06/25/5.MyBatis%E4%B8%8ESpring%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="MyBatis与Spring整合"><a href="#MyBatis与Spring整合" class="headerlink" title="MyBatis与Spring整合"></a>MyBatis与Spring整合</h1><p>官网：</p>
<p><a href="http://www.mybatis.org/spring/zh/index.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/zh/index.html</a> </p>
<p><a href="https://github.com/mybatis/spring" target="_blank" rel="noopener">https://github.com/mybatis/spring</a> </p>
<p>在MyBatis的原生API中， 有三个对外提供的核心对象：SqISessionFactory,SqlSession, getMapper()返回的代理对象（里面有一个 h对象MapperProxy的实例）。</p>
<p>虽然MyBatis对JDBC进行封装之后， 已经大大地简化了我们对于数据库的操作，但是在我们的业务代码里面， 不断地创建、 释放 SqlSession 也是一件很麻烦的事情。    </p>
<p>所以， 在 Spring 的工程里面， 有没有更加简单的使用 MyBatis 的方法呢？</p>
<p>实际上，MyBatis 基于 Spring 的扩展接口，对原生 API 中的操作进一步进行了简化，</p>
<p>这个也是为什么为什么在 Spring 里面使用 MyBatis 的时候，没有看到这三个对象在代码里面的出现的原因。我们只需要把 Mapper 接口注入到需要的地方，调用它的方法就 OK了。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DepartmentMapper departmentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Department&gt; <span class="title">getDepts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//直接引入就可以调用Mapper中的方法	</span></span><br><span class="line">        List&lt;Department&gt; list = departmentMapper.selectByMap(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 中， 有几个关键的问题， 我们要弄清楚：</p>
<p>1.如果用＠Autowired 注入一个接口， 调用接口的方法就可以找到 SQL 执行，这个接口在 loC 容器中也是一个代理对象吗？</p>
<p>2.如果是代理对象， 还是不是 SqlSession 用 getMapper(）获得的代理对象？SqlSession 又是什么时候创建的？</p>
<p>3.每个会话都要产生一个SqlSession，单例的SqlSessionFactory是什么时候创建的？</p>
<h2 id="1-关键配置"><a href="#1-关键配置" class="headerlink" title="1.关键配置"></a>1.关键配置</h2><p>首先看看把MyBatis集成到Spring中要做的几件事情。</p>
<ul>
<li><p>pom依赖</p>
<p>首先，除了MyBatis的依赖之外我们还需要在pom文件中引入MyBatis和Spring整合的jar包。</p>
<p>这里要注意两点这个包名叫mybatis-spring,而不是spring-mybatis，是因为它是MyBatis利用Spring的接口开发的。</p>
<p>其次：mybatis的版本和 mybatis-spring的版本有兼容关系， 版本要对应。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis 和Spring整合 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SqlSessionFactoryBean </p>
<p>然后在Spring的applicationContext.xml里面配置SqlSessionFactoryBean。 很明显， 这个Bean会初始化一个SqlSessionFactory， 用来帮我们创建SqlSession。</p>
<p>它的属性还要指定全局配置文件 mybatis-config.xmI和Mapper映射器文件的路径。 数据源也是由Spring来管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mybatis-spring</span>=<span class="string">"http://mybatis.org/schema/mybatis-spring"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-2.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/aop/spring-aop-2.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/tx/spring-tx-2.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gxedu.crud"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:include-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbc"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath*:jdbc.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring的连接池 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="url" value="$&#123;url&#125;"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="username" value="$&#123;username&#125;"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="password" value="$&#123;password&#125;"/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.driverClassName&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.url&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.username&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.password&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.maxActive&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.initialSize&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.minIdle&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.maxWait&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.timeBetweenEvictionRunsMillis&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.minEvictableIdleTimeMillis&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.testWhileIdle&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.testOnBorrow&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.testOnReturn&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.poolPreparedStatements&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxOpenPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"$&#123;druid.maxOpenPreparedStatements&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在Spring启动时创建 sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置扫描器，将mybatis的接口实现加入到  IOC容器中  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;mybatis-spring:scan #base-package="com.gxedu.crud.dao"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.gxedu.crud.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 接口的普通注册方式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;bean id="employeeMapper" class="org.mybatis.spring.mapper.MapperFactoryBean" autowire="byType"&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name="mapperInterface" value="com.gxedu.crud.dao.EmployeeMapper" /&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DAO层的实现类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"employeeDao"</span> <span class="attr">class</span>=<span class="string">"com.gxedu.crud.daosupport.EmployeeDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置一个可以执行批量的sqlSession，全局唯一，单例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">"BATCH"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启事务控制--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.gxedu.crud.service..*(..))"</span> <span class="attr">id</span>=<span class="string">"txPoint"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"txPoint"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MapperScannerConfigurer</p>
<p>然后在applicationContext.xml配置需要扫描Mapper接口的路径。</p>
<p>有几种方式，第一种是配置一个MapperScannerConfigurer。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">" com.gxedu.crud.dao"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种是配置一个<scan>标签：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mybatis-spring:</span> <span class="attr">scanbase-package</span>=<span class="string">" com.gxedu.crud.dao"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一种就是直接用＠MapperScan 注解， 比如我们在Spring Boot的启动类上加上个注解：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.gxedu.crud.dao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybaitsApp</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">		SpringApplication.run(MybaitsApp. <span class="class"><span class="keyword">class</span>, <span class="title">args</span>)</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三种方式实现的效果是—样的。</p>
<p>经过这两步(SqlSessionFactoryBean + MapperScannerConfigurer)配置以后，</p>
<p>Mapper就可以注入到Service层使用了， MyBatis其他的代码和配置不需要做任何的改动。</p>
<p>它是怎么实现的呢？</p>
<p>把MyBatis集成到Spring里面 ， 是为了进—步简化MyBatis的使用， 所以只是对MyBatis 做了—些封装，并没有替换MyBatis的核心对象。也就是说：MyBatis jar 包中的SqISessionFactory,SqlSession,MapperProxy 这些类都会用到。mybatis-spring.jar 里面的类只是做了—些包装或者桥梁的工作。</p>
<p>只要我们弄明白了这三个对象是怎么创建的，也就理解了Spring继承MyBatis的原理。 我们把它分成三步：</p>
<ol>
<li><p>SqlSessionFactory在哪创建的。</p>
</li>
<li><p>SqlSession在哪创建的。</p>
</li>
<li><p>代理类在哪创建的。</p>
</li>
</ol>
</li>
</ul>
<h2 id="2-创建会话工厂SqlSessionFactory"><a href="#2-创建会话工厂SqlSessionFactory" class="headerlink" title="2.创建会话工厂SqlSessionFactory"></a>2.创建会话工厂SqlSessionFactory</h2><p>  第一步,我们看 —下在Spring里面， SqlSessionFactory是怎么创建的。</p>
<p>  我们在Spring的配置文件中配置了—个SqlSessionFactoryBean,看下这个类的内容:</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在Spring启动时创建 sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  它实现了三个接口：lnitializingBean,FactoryBean,ApplicationListener</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/17/XpvyYs2dL6TF5n7.png" alt="image.png"></p>
<p>实现这三个接口意味着什么呢？</p>
<ul>
<li><p>InitializingBean</p>
<p>实现了lnitializingBean 接口 ， 所以要实现afterPropertiesSet(）方法， 这个方法会在bean的属性值设置完的时候被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">SqlSessionFactory</span>&gt;, <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MetadataReaderFactory METADATA_READER_FACTORY = <span class="keyword">new</span> CachingMetadataReaderFactory();</span><br><span class="line">    <span class="keyword">private</span> Resource configLocation;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> Resource[] mapperLocations;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> TransactionFactory transactionFactory;</span><br><span class="line">    <span class="keyword">private</span> Properties configurationProperties;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactoryBuilder sqlSessionFactoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> String environment = SqlSessionFactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="keyword">private</span> Interceptor[] plugins;</span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt;[] typeHandlers;</span><br><span class="line">    <span class="keyword">private</span> String typeHandlersPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] typeAliases;</span><br><span class="line">    <span class="keyword">private</span> String typeAliasesPackage;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; typeAliasesSuperType;</span><br><span class="line">    <span class="keyword">private</span> LanguageDriver[] scriptingLanguageDrivers;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;</span><br><span class="line">    <span class="keyword">private</span> DatabaseIdProvider databaseIdProvider;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends VFS&gt; vfs;</span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> ObjectFactory objectFactory;</span><br><span class="line">    <span class="keyword">private</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.dataSource, <span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">        Assert.notNull(<span class="keyword">this</span>.sqlSessionFactoryBuilder, <span class="string">"Property 'sqlSessionFactoryBuilder' 														is required"</span>);</span><br><span class="line">        Assert.state(<span class="keyword">this</span>.configuration == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.configLocation == <span class="keyword">null</span> || <span class="keyword">this</span>.configuration == <span class="keyword">null</span> || <span class="keyword">this</span>.configLocation == <span class="keyword">null</span>, <span class="string">"Property 'configuration' and 'configLocation' can not specified with together"</span>);</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionFactory = <span class="keyword">this</span>.buildSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在afterPropertiesSet() 方法里面， 经过一些检查之后 ， 调用了buildSqlSessionFactory(）方法。</p>
<p>这里创建了一个Configuration对象，叫做targetConfiguration。还创建了一个用来解析全局配置文件的 XMLConfigBuilder。</p>
<p>后面就 是基于当前SqlSessionFactoryBean 对象里面已有的属性， 对targetConfiguration对象里面属性的赋值。</p>
<p>Optional.ofNullable()是Java8里面的一判空的方法。如果不为空的话，就会调用括号里面的对象的方法，把解析出来的属性，赋值给SqlSessionFactoryBean的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Configuration targetConfiguration;</span><br><span class="line">   Optional var10000;	    </span><br><span class="line">var10000 = Optional.ofNullable(<span class="keyword">this</span>.objectFactory);</span><br><span class="line">   var10000.ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">   var10000 = Optional.ofNullable(<span class="keyword">this</span>.objectWrapperFactory);</span><br><span class="line">   var10000.ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">   var10000 = Optional.ofNullable(<span class="keyword">this</span>.vfs);</span><br><span class="line">   var10000.ifPresent(targetConfiguration::setVfsImpl);</span><br></pre></td></tr></table></figure>

<p>后面对于typeAliases,plugins,typeHandlers的解析， 都是调用Configuration类的方法。</p>
<p>如果XMLConfigBuilder不为空， 也就是上面的第二种情况， 调用了XMLConfigBuilder. parse(）去解析配置文件， 最终会返回解析好的 Configuration对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLConfigBuilder.parse();</span><br></pre></td></tr></table></figure>

<p>这个方法在讲解源码的时候已经详细分析过了，这里不再重复。</p>
<p>接下来先判断事务工厂是否存在。 这个事务工厂， 是解析 environments标签的时候， 根据<transaction Manager>子标签创建的。</p>
<p>只有JDBC或者MANAGED这两个值。如果没有配置，比如数据源交给Spring管理的时候，这里就是空的。</p>
<p>此时会new一个SpringManagedTransactionFactory, 放在Environment里面。这个事务工厂获取的事务是SpringManagedTransaction对象，定义了getConnection(）、close(）、commit(）、rollback(）等方法。</p>
<p><img src="https://i.loli.net/2020/05/17/lvCbVws3knzJ1dq.png" alt="image.png"></p>
<p>接下来创建 了一个用来解析 Mapper.xml的XMLMapperBuilder,调用了它的parse(）方法。这个步骤我们之前了解过了，主要做了两件事情，</p>
<p>—个是把增删改查标签注册成MappedStatement对象,</p>
<p>第二个是把接口和对应的MapperProxyFactory工厂类注册到MapperRegistry中。</p>
<p>MapperRegistry就是一个Map</p>
<p> (Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers = new HashMap&lt;&gt;();)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 总体上做了两件事情，对于语句的注册和接口的注册</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 1、具体增删改查标签的解析。</span></span><br><span class="line">      <span class="comment">// 一个标签一个MappedStatement。 &gt;&gt;</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">// 2、把namespace（接口类型）和工厂类绑定起来，放到一个map。</span></span><br><span class="line">      <span class="comment">// 一个namespace 一个 MapperProxyFactory &gt;&gt;</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用sqlSessionFactoryBuiIder. buiId() 返回一个DefaultSqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> SqlSessionFactory <span class="title">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        XMLConfigBuilder xmlConfigBuilder = <span class="keyword">null</span>;</span><br><span class="line">        Configuration targetConfiguration;</span><br><span class="line">        Optional var10000;</span><br><span class="line">    <span class="comment">//判断Configuration对象是否已经存在， 也就是是否已经解析过。如果已经有对象， 就覆盖下属性。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration != <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetConfiguration = <span class="keyword">this</span>.configuration;</span><br><span class="line">            <span class="keyword">if</span> (targetConfiguration.getVariables() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetConfiguration.setVariables(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configurationProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经有对象， 就覆盖下属性。</span></span><br><span class="line">                targetConfiguration.getVariables().putAll(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果Configuration不存在， </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.configLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//但是配置了configlocation属性， 就根据mybatis-config.xml的文件路径， 构建一个XMLConfigBuilder对象。</span></span><br><span class="line">            xmlConfigBuilder = <span class="keyword">new</span> XMLConfigBuilder(<span class="keyword">this</span>.configLocation.getInputStream(), (String)<span class="keyword">null</span>, <span class="keyword">this</span>.configurationProperties);</span><br><span class="line">            targetConfiguration = xmlConfigBuilder.getConfiguration();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration"</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//否则，Configuration对象不存在，configlocation路径也没有，只能使用默认属性去构建去给configurationProperties赋值。</span></span><br><span class="line">            targetConfiguration = <span class="keyword">new</span> Configuration();</span><br><span class="line">            var10000 = Optional.ofNullable(<span class="keyword">this</span>.configurationProperties);</span><br><span class="line">            Objects.requireNonNull(targetConfiguration);</span><br><span class="line">            var10000.ifPresent(targetConfiguration::setVariables);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var10000 = Optional.ofNullable(<span class="keyword">this</span>.objectFactory);</span><br><span class="line">        Objects.requireNonNull(targetConfiguration);</span><br><span class="line">        var10000.ifPresent(targetConfiguration::setObjectFactory);</span><br><span class="line">        var10000 = Optional.ofNullable(<span class="keyword">this</span>.objectWrapperFactory);</span><br><span class="line">        Objects.requireNonNull(targetConfiguration);</span><br><span class="line">        var10000.ifPresent(targetConfiguration::setObjectWrapperFactory);</span><br><span class="line">        var10000 = Optional.ofNullable(<span class="keyword">this</span>.vfs);</span><br><span class="line">        Objects.requireNonNull(targetConfiguration);</span><br><span class="line">        var10000.ifPresent(targetConfiguration::setVfsImpl);</span><br><span class="line">        Stream var24;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.typeAliasesPackage)) &#123;</span><br><span class="line">            var24 = <span class="keyword">this</span>.scanClasses(<span class="keyword">this</span>.typeAliasesPackage, <span class="keyword">this</span>.typeAliasesSuperType).stream().filter((clazz) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">            &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">            &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> !clazz.isMemberClass();</span><br><span class="line">            &#125;);</span><br><span class="line">            TypeAliasRegistry var10001 = targetConfiguration.getTypeAliasRegistry();</span><br><span class="line">            Objects.requireNonNull(var10001);</span><br><span class="line">            var24.forEach(var10001::registerAlias);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//继续typeAliases</span></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.typeAliases)) &#123;</span><br><span class="line">            Stream.of(<span class="keyword">this</span>.typeAliases).forEach((typeAlias) -&gt; &#123;</span><br><span class="line">                targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span><br><span class="line">                LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Registered type alias: '"</span> + typeAlias + <span class="string">"'"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//解析插件</span></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">            Stream.of(<span class="keyword">this</span>.plugins).forEach((plugin) -&gt; &#123;</span><br><span class="line">                targetConfiguration.addInterceptor(plugin);</span><br><span class="line">                LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Registered plugin: '"</span> + plugin + <span class="string">"'"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解析typeHandlerPackage</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(<span class="keyword">this</span>.typeHandlersPackage)) &#123;</span><br><span class="line">            var24 = <span class="keyword">this</span>.scanClasses(<span class="keyword">this</span>.typeHandlersPackage, TypeHandler<span class="class">.<span class="keyword">class</span>).<span class="title">stream</span>().<span class="title">filter</span>((<span class="title">clazz</span>) -&gt; </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> !clazz.isAnonymousClass();</span><br><span class="line">            &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> !clazz.isInterface();</span><br><span class="line">            &#125;).filter((clazz) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> !Modifier.isAbstract(clazz.getModifiers());</span><br><span class="line">            &#125;);</span><br><span class="line">            TypeHandlerRegistry var25 = targetConfiguration.getTypeHandlerRegistry();</span><br><span class="line">            Objects.requireNonNull(var25);</span><br><span class="line">            var24.forEach(var25::register);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.typeHandlers)) &#123;</span><br><span class="line">            Stream.of(<span class="keyword">this</span>.typeHandlers).forEach((typeHandler) -&gt; &#123;</span><br><span class="line">                targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span><br><span class="line">                LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Registered type handler: '"</span> + typeHandler + <span class="string">"'"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.scriptingLanguageDrivers)) &#123;</span><br><span class="line">            Stream.of(<span class="keyword">this</span>.scriptingLanguageDrivers).forEach((languageDriver) -&gt; &#123;</span><br><span class="line">                targetConfiguration.getLanguageRegistry().register(languageDriver);</span><br><span class="line">                LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Registered scripting language driver: '"</span> + languageDriver + <span class="string">"'"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var10000 = Optional.ofNullable(<span class="keyword">this</span>.defaultScriptingLanguageDriver);</span><br><span class="line">        Objects.requireNonNull(targetConfiguration);</span><br><span class="line">        var10000.ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetConfiguration.setDatabaseId(<span class="keyword">this</span>.databaseIdProvider.getDatabaseId(<span class="keyword">this</span>.dataSource));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException var23) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed getting a databaseId"</span>, var23);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var10000 = Optional.ofNullable(<span class="keyword">this</span>.cache);</span><br><span class="line">        Objects.requireNonNull(targetConfiguration);</span><br><span class="line">        var10000.ifPresent(targetConfiguration::addCache);</span><br><span class="line">        <span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正调用myBatis的parse()进行解析</span></span><br><span class="line">                xmlConfigBuilder.parse();</span><br><span class="line">                LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Parsed configuration file: '"</span> + <span class="keyword">this</span>.configLocation + <span class="string">"'"</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var21) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse config resource: "</span> + <span class="keyword">this</span>.configLocation, var21);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ErrorContext.instance().reset();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先判断事务工厂是否存在。 这个事务工厂， 是解析 environments标签的时候， 根据&lt;transact ionManager&gt;子标签创建的。</span></span><br><span class="line">        targetConfiguration.setEnvironment(<span class="keyword">new</span> Environment(<span class="keyword">this</span>.environment, (TransactionFactory)(<span class="keyword">this</span>.transactionFactory == <span class="keyword">null</span> ? <span class="keyword">new</span> SpringManagedTransactionFactory() : <span class="keyword">this</span>.transactionFactory), <span class="keyword">this</span>.dataSource));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mapperLocations.length == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.warn(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Property 'mapperLocations' was specified but matching resources are not found."</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Resource[] var3 = <span class="keyword">this</span>.mapperLocations;</span><br><span class="line">                <span class="keyword">int</span> var4 = var3.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                    Resource mapperLocation = var3[var5];</span><br><span class="line">                    <span class="keyword">if</span> (mapperLocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(), targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span><br><span class="line">                            xmlMapperBuilder.parse();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">"Failed to parse mapping resource: '"</span> + mapperLocation + <span class="string">"'"</span>, var19);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            ErrorContext.instance().reset();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">"Parsed mapper file: '"</span> + mapperLocation + <span class="string">"'"</span>;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGGER.debug(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Property 'mapperLocations' was not specified."</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">	    <span class="comment">//通过sqlSessionFactoryBuilder.build()方法返回一个DefaultSessionFactory工厂	</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactoryBuilder.build(targetConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  <strong><em>总结一下:</em></strong></p>
<p>  通过定义一个个实现了lnitializingBean接口的SqlSessionFactoryBean类，里面有一个afterPropertiesSet(）方法会在bean的属性值设置完的时候被调用。Spring在启动初始化这个Bean的时候，完成了解析和工厂类的创建工作。</p>
<ul>
<li><p>FactoryBean</p>
<p>另外SqlSessionFactoryBean实现了FactoryBean接口。FactoryBean的作用是让用户可以自定义实例化Bean的逻辑。如果从BeanFactory 中根据Bean的ID获取一个Bean, 它获取的其实是FactoryBean的getObject(）返回的对象。</p>
<p>也就是说， 我们获取 SqlSessionFactoryBean的时候， 就会调用它的getObject()方法。</p>
<p>而getObject(）方法也是调用了afterPropertiesSet(）方法， 去做MyBatis解析配置文件的工作， 返回一个DefaultSqlSessionFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sqlSessionFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ApplicationListener<ApplicationEvent></p>
<p>实现ApplicationListener接口让SqlSessionFactoryBean有能力监控应用发出的一些事件通知。</p>
<p>调用void onApplicationEvent(E var1);方法,</p>
<p>比如这里监听了ContextRefreshedEvent（上下文刷新事件），会在Spring容器加载完之后执行。</p>
<p>这里做的事情是检查MappedStatement是否加载完毕。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.failFast &amp;&amp; event <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            <span class="comment">//检查MappedStatement是否加载完毕</span></span><br><span class="line">            <span class="keyword">this</span>.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/17/a4YlzOVBq8HefI1.png" alt="image.png"></p>
</li>
</ul>
<h2 id="创建会话SqlSession"><a href="#创建会话SqlSession" class="headerlink" title="创建会话SqlSession"></a>创建会话SqlSession</h2><p>为什么不能直接使用DefaultSqlSession?</p>
<p>我们现在已经有一个DefaultSqlSessionFactory, 按照编程式的开发过程， 我们接下来就会用openSession(）创建一个SqlSession的实现类。</p>
<p>但是在Spring里面， 我们不是直接使用DefaultSqlSession 的。 为什么不用DefaultSqlSession?它是线程不安全的，注意看类上的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note that this class is not Thread-Safe.&#x2F;&#x2F;不是线程安全的</span><br></pre></td></tr></table></figure>

<p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/getting-started.html</a> </p>
<p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 ， 在Spring 里面， 我们要保证SqlSession实例的线程安全 ， 必须为每—次请求单独创建—个SqlSession。 但是每—次请求用openSession(）自己去创建， 又会比较麻烦。</p>
<p>在mybatis-spring的包中 ， 提供了—个线程安全的SqlSession的包装类， 用来替代SqlSession, 这个 类就是SqlSessionTemplate。 因为它是线程安全的， 所以可以在所有的DAO层共享—个实例（默认是单例的） 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个可以执行批量的sqlSession，全局唯一，单例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>  <span class="attr">value</span>=<span class="string">"BATCH"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SqlSessionTemplate虽然踉DefaultSqlSession一样定义了操作数据的selectOne(）、 selectlist(）、 insert(）、 update(）、 delete(）等所有 方法， 但是没有 自己的实现， 全部 调用了—个代理对象的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread safe, Spring managed, &#123;@code SqlSession&#125; 线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">    notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="comment">//通过JDK的动态代理创建代理对象</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.selectOne(statement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代理对象是怎么来的？在构造方法里面通过JDK动态代理创建：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br></pre></td></tr></table></figure>

<p>它是对SqlSession实现类DefaultSqlSession的代理。既然是JDK动态代理，那对代理类任意方法的调用都会走到（第三个参数）实现了lnvocationHandler接口的触发管理类SqlSessionInterceptor的invoke(）方法。</p>
<p>SqlSessionInterceptor是—个内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    SqlSession sqlSession = getSqlSession(SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.executorType, SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object result = method.invoke(sqlSession, args);</span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator</span><br><span class="line">            .translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先用 getSqlSession(）方 法创建一个SqlSession 对象，把SqlSessionFactory、 执行器类型、 异常解析器传进去。</p>
<p>获得SqlSession实例（实际上是DefaultSqlSession)之后，再调用它的增删改查的方法。</p>
<p><strong>总结一下:</strong></p>
<p>因为DefaultSqlSession自己做不到每次请求调用产生一个新的实例，我们干脆创建一个代理类，也实现SqlSession，提供跟DefaultSqlSession一样的方法，在任何一个方法被调用的时候都先创建一个DefaultSqlSession实例，再调用被代理对象的相应方法。</p>
<p>MyBatis还自带了一个线程安全的 SqlSession实现：SqlSessionManager,实现方式一样，如果不集成到Spring要保证线程安全，就用SqlSessionManager。</p>
<p>跟JdbcTemplate, RedisTemplate一样，SqlSessionTemplate 可以简化MyBatis在Spring中的使用，也是Spring跟M·yBatis整合的最关键的一个类。</p>
<p>怎么拿到一个SqlSessionTemplate?</p>
<p>因为SqlSessionTemplate是线程安全的 ，可以替换DefaultSqlSession,那在DAO层怎么拿到个SqlSessionTemplate呢？</p>
<p>在applicationContext.xml里面配置一个 bean, 用＠Autowired注入到需要使用的地方不就好了？</p>
<p>但是，我们这里并没有显式地定义一个 SqlSessionTemplate 的 bean, 是不能直接注入的。 所以，问题是， 如果不用注入的方式，怎么获得一个 SqlSessionTemplate?</p>
<p>在 new一个可以吗？也可以，它有三个重载的构造函数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">  notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">  <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">  <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">  <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">      new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new 出来但是可以，但是 这个单例的 SqlSessionTemplate 必须存起来放在一个地方，可以在任何需要替代 DefaultSqlSession 的地方都可以拿到，不能重复 new, 否则就不是单例了。</p>
<p>所以要存在一个什么地方呢？或者说，我们是不是提供一个工具类用来获取单例的SqlSessionTemplate 呢？</p>
<p>在 Hibernate 中， 如果不用注入 的方式，我们在 DAO 层注 入一个HibernateTemplate 的一种方法是什么？</p>
<p>——-让我们DAO 层的实现类去继承 HibernateDaoSupport。</p>
<p>MyBatis里面也 是一样的，它提供了一个抽象的支持类SqlSessionDaoSupport。</p>
<p>官网：<a href="http://mybatis.org/spring/zh/sqlsession.html" target="_blank" rel="noopener">http://mybatis.org/spring/zh/sqlsession.html</a></p>
<p>SqlSessionDaoSupport类中持有一个SqlSessionTemplate对象 ，并且提供了个getSqlSession(）方法， 让我们获得一个SqlSessionTemplate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">getSqlSessionTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionTemplate;	</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说我们让DAO层（实现类）继承抽象类SqlSessionDaoSupport,就自动拥有了getSqlSession(）方法。调用getSqlSession(）就能拿到共享的SqlSessionTemplate。</p>
<p>在DAO层执行SQL格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getSqlSession().selectOne(statement, parameter); </span><br><span class="line">getSqlSession().insert(statement); </span><br><span class="line">getSqlSession().update(statement); </span><br><span class="line">getSqlSession().delete(statement);</span><br></pre></td></tr></table></figure>

<p>还是不够简洁。 为了减少重复的代码，我们通常不会让我们的实现类直接去继承SqlSessionDaoSupport,而是先创建一个BaseDao继承SqlSessionDaoSupport。在BaseDao里面封装对数据库的操作，包括SelectOne(） 、selectlist(）,insert(）,delete()这些方法， 子类就可以直接调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> </span>&#123; </span><br><span class="line">	<span class="comment">//使用 sqlSessionFactory </span></span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> getSqlSession(). selectOne(statement, parameter); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让我们的DAO层 实现类继承BaseDao并且实现我们的Mapper接口。实现类需要加上＠Repository的注解。</p>
<p>在实现类的方法里面，我们可以直接调用父类(BaseDao)封装的selectOne(）方法，那么它最终会调用 sqlSessionTemplate的selectOne(）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span> <span class="keyword">implements</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂时只实现了这一个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> empId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">selectByPrimaryKey</span><span class="params">(Integer empId)</span> </span>&#123;</span><br><span class="line">        Employee emp = (Employee) <span class="keyword">this</span>.selectOne(<span class="string">"com.gupaoedu.crud.dao.EmployeeMapper.selectByPrimaryKey"</span>,empId);</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: qingshan</span></span><br><span class="line"><span class="comment"> *  通过继承SqlSessionDaoSupport 获得一个 SqlSessionTemplate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用sqlSessionFactory</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用getSqlSession()方法获取sqlSessionTemplate</span></span><br><span class="line">        <span class="keyword">return</span> getSqlSession().selectOne(statement, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionTemplate;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//调用SqlSessionTemplate的selectOne()方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用代理对象调用selectOne()方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.selectOne(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sqlSessionProxy使用jdk的动态代理创建代理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">    notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">    <span class="comment">//创建代理对象</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">        new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>有没有更好的拿到SqlSessionTemplate的方法？</p>
<p>我们的每一个 DAO 层的接口 (Mapper 接口也属于）， 如果要拿到一SqlSessionTemplate, 去操作数据库，都要创建实现一个实现类，加上＠ Repository 的注解， 继承 BaseDao, 这个工作量也不小。</p>
<p>另外一个，我们去直接调用 selectOne(）方法，还是出现了 Statement ID的硬编码 。也就是说它没有用到JDK 动态代理， 在调用接口方法的时候通过 MapperProxy 自动找到对应的 Statement ID。</p>
<p>怎么办呢？不继承SqlSessionDaoSupport就拿不到SqlSessionTemplate了吗？</p>
<p>SqlSessionTemplate硬编码的问题又怎么解决？</p>
<p>但是我们在实际的Spring 项目里面也没有这么做。我们是直接注入了一个 Mapper接口， 调用它的方法就OK 了。</p>
<p>那这个 Mapper接口是怎么拿到SqlSessionTemplate的？当我们调用方法的时候，还会不会通过MapperProxy?</p>
<p>这个 Mapper 接口可以＠Autowired 注入到任何地方的话， 它肯定是在容器BeanFactory （比如 XmlWebApplicationContext) 中注册过了。</p>
<p>问题是：</p>
<p>1.什么时候注册到容器中的？</p>
<p>2.注册的时候， 注册的是什么对象？ 是代理对象吗？</p>
<h2 id="4-接口的扫描注册"><a href="#4-接口的扫描注册" class="headerlink" title="4.接口的扫描注册"></a>4.接口的扫描注册</h2><p>回顾一下， 我们在 applicationContext.xml里 面配置了一个MapperScannerConfigurer,它是用来扫描Mapper接口的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--配置扫描器，将mybatis的接口实现加入到  IOC容器中  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;mybatis-spring:scan #base-package="com.gxedu.crud.dao"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mapperScanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.gxedu.crud.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor接口。BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor的子类，里面有一个postProcessBeanDefinitionRegistry(） 方法。</p>
<p>实现了这个接口， 就可以在Spring创建Bean之前， 修改某些Bean在容器中的定义。Spring创建Bean之前会调用这个方法。</p>
<p>MapperScannerConfigurer重写了postProcessBeanDefinitionRegistry(）， 那它要做什么呢？</p>
<p>在这个方法里面：</p>
<p>创建了一个scanner对象， 然后设置属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperScannerConfigurer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">InitializingBean</span>, <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner = <span class="keyword">new</span> ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="keyword">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="keyword">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="keyword">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="keyword">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="keyword">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="keyword">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="keyword">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">      scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">      <span class="comment">//调用ClassPathBeanDefinitionScanner的scan(）方法：</span></span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(<span class="keyword">this</span>.basePackage, 				          						ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;		</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanDefinitionRegistryPostProcessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用ClassPathBeanDefinitionScanner的scan(）方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//调用子类ClassPathMapperScanner的doScan()方法</span></span><br><span class="line">        <span class="keyword">this</span>.doScan(basePackages);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">            AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123; </span><br><span class="line">    </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//调用父类的doScan()方法,扫描所有的接口,把接口全部添加到BeanDefinition中</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      LOGGER.warn(() -&gt; <span class="string">"No MyBatis mapper was found in '"</span> + Arrays.toString(basePackages)</span><br><span class="line">          + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//修改bean</span></span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathBeanDefinitionScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用父类的doScan()方法,把接口全部添加到BeanDefinition中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        String[] var3 = basePackages;</span><br><span class="line">        <span class="keyword">int</span> var4 = basePackages.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String basePackage = var3[var5];</span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = <span class="keyword">this</span>.findCandidateComponents(basePackage);</span><br><span class="line">            Iterator var8 = candidates.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BeanDefinition candidate = (BeanDefinition)var8.next();</span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    <span class="keyword">this</span>.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.子类的ClassPathMapperScanner又调用父类ClassPathBeanDefinitionScanner的doScan(）扫描所有的接口 , 把接口全部添加到BeanDefinitions中。</p>
<p>2.在processBeanDefinitions(）方法里面 ， 在注册beanDefinitions的时候 ，BeanClass被改为MapperFactoryBean也就是说， 所有的 Mapper 接口， 在容器里面都被注册成一个支持泛型的MapperFactoryBean<T> 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathMapperScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = MapperFactoryBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">          definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">          String beanClassName = definition.getBeanClassName();</span><br><span class="line">          LOGGER.debug(() -&gt; <span class="string">"Creating MapperFactoryBean with name '"</span> + holder.getBeanName() + <span class="string">"' and '"</span> + beanClassName</span><br><span class="line">              + <span class="string">"' mapperInterface"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// the mapper interface is the original class of the bean</span></span><br><span class="line">          <span class="comment">// but, the actual class of the bean is MapperFactoryBean 实际注册的对象是MapperFactoryBean</span></span><br><span class="line">          definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); </span><br><span class="line">          <span class="comment">//BeanClass实际是MapperFactoryBean</span></span><br><span class="line">          definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBeanClass);</span><br><span class="line">          definition.getPropertyValues().add(<span class="string">"addToConfig"</span>, <span class="keyword">this</span>.addToConfig);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要注册成它呢？那注入使用的时候， 也是这个对象， 这个对象有什么作用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承了抽象类 SqlSessionDaoSupport, 这不就解决了我们的第一个问题了， 现在每一个注入 Mapper的地方， 都可以拿到SqlSessionTemplate。</p>
<p>现在只剩下最后一个问题了， 有没有用到 MapperProxy? 如果注册的是MapperFactoryBean, 难道注入使用的也是MapperFactoryBean 吗？这个类并不是代理类。</p>
<h2 id="5-接口注入的使用"><a href="#5-接口注入的使用" class="headerlink" title="5.接口注入的使用"></a>5.接口注入的使用</h2><p>所以注入的到底是一个什么对象？注意看MapperFactoryBean  也实现了FactoryBean, 我们已经见过次了。 它可以在 getObject(）中修改获取 Bean实例的行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它并没有直接返回一个MapperFactoryBean。而是调用了SqlSessionTemplate的getMapper(）方法。SqlSessionTemplate的本质是一个代理，所以它最终会调用DefaultSqlSession的getMapper(）方法。后面的流程我们就不重复了。也就是说，最后返回的还是一个JDK的动态代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="comment">//接口namespace对应一个MapperProxyFactorty工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperRegistry</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用MapperRegistry的getMapper()方法获取代理对象</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">        <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">        <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用MapperProxyFactory的newInstance()方法获取jdk的动态代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以最后调用 Mapper接口的任何方法，也 是执行MapperProxy的invoke(）方法，后面的流程就跟编程式的工程里面一模一样了.</p>
<p><strong>总结一下</strong>:</p>
<p>Spring 是怎么把MyBatis 继承进去的？</p>
<ol>
<li>提供了 SqlSession的替代品SqlSessionTemplate， 里面有一个实现了lnvocationHandler的内部SqlSessionlnterceptor, 本质是对SqlSession的代理。</li>
<li>提供了获取SqlSessionTemplate的抽象类SqlSessionDaoSupport。</li>
<li>扫描Mapper接口 ， 注册到容器中的是MapperFactoryBean, 它继承了SqlSessionDaoSupport, 可以获得SqlSessionTemplate。</li>
<li>把Mapper注入使用的时候， 调用的是getObject(）方法， 它实际上是调用了SqlSessionTemplate的getMapper(）方法，注入了一个JDK动态代理对象。</li>
<li>执行Mapper接口的任意方法， 会走到触发管理类MapperProxy, 进入 SQL处理 流程。</li>
</ol>
<p><strong>学到了什么？</strong></p>
<ol>
<li><p>为组件预留扩展接口</p>
</li>
<li><p>利用 Spring的扩展机制， 把组件集成到 MyBatis中 。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2020/05/17/5kIlHtXq46hACPg.png" alt="image.png"></p>
<p>MapperFactoryBean补充: 实现了FactoryBean接口,调用getObject()方法获取的不是MapperFactoryBean对象,</p>
<p>而是jdk的代理对象.</p>
<h2 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h2><p><img src="https://i.loli.net/2020/05/17/LzIqctRWQDOdXk8.png" alt="image.png"></p>
<p>自己总结关键点:</p>
<p><strong>1.获取SqlSessionFactory对象</strong></p>
<p>   首先是在spring的配置文件中定义了sqlSessionFactoryBean这个bean对象,</p>
<ul>
<li><p>①.由于sqlSessionFactoryBean实现了InitializingBean接口,实现了这个接口的会bean初始化的时候调用                afterPropertiesSet ()方法,这个方法里边定义了使用XmlConfigBuilder去解析我们mybatis-config.xml的全局配置文件,使用XmlMapperBuilder去解析我们的Mapper映射文件标签,使用XmlStatementBuilder去解析我们select|update|insert|delete标签以及动态标签,包含sql语句标签等等,并且是一个标签对应一个MappedStatement对象,接下来会去把namespace（接口类型）和工厂类绑定起来，放到一个map,一个namespace 一个 MapperProxyFactory.最后将我们解析都存到configuration对象中,并且new 一个DefaultSqlSessionFactory对象返回.</p>
</li>
<li><p>②.sqlSessionFactoryBean还实现了FactoryBean&lt;?&gt;接口,这个接口中的getObject()方法是用来获取指定类型的bean对象FactoryBean<SqlSessionFactory>,最后返回一个sqlSessionFactory对象</p>
<p>FactoryBean的作用是让用户可以自定义实例化Bean的逻辑。如果从BeanFactory 中根据Bean的ID获取一个Bean, 它获取的其实是FactoryBean的getObject(）返回的对象。</p>
<p>也就是说， 我们获取 SqlSessionFactoryBean的时候， 就会调用它的getObject()方法。</p>
<p>而getObject(）方法也是调用了afterPropertiesSet(）方法， 去做MyBatis解析配置文件的工作， 返回一个DefaultSqlSessionFactory。</p>
</li>
<li><p>③.sqlSessionFactoryBean还实现了ApplicationListener<ApplicationEvent>接口,这个接口中onApplicationEvent()方法用来监听spring的上下文刷新事件，会在Spring容器加载完之后执行。</p>
<p>这里做的事情是检查MappedStatement是否加载完毕。</p>
</li>
</ul>
<p><strong>2.获取SqlSession对象</strong></p>
<p>​    ①.由于我们的sqlSession对象是不安全的,</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>整合spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis源码解读以及设计思想</title>
    <url>/gxblog/2020/06/25/3.MyBatis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="1、通过阅读MyBatis源码掌握MyBatis底层工作原理与设计思想"><a href="#1、通过阅读MyBatis源码掌握MyBatis底层工作原理与设计思想" class="headerlink" title="1、通过阅读MyBatis源码掌握MyBatis底层工作原理与设计思想"></a>1、通过阅读MyBatis源码掌握MyBatis底层工作原理与设计思想</h1><p>我们分成五步来分析。</p>
<p>第一步， 我们创建一个工厂类， 配置文件的解析就是在这一步完成的， 包括mybatis-config.xml 和 Mapper 映射器文件。</p>
<p>这一步我们关心的内容：解析的时候做了什么， 产生了什么对象， 解析的结果存放到了哪里。 解析的结果决定着我们后面有什么对象可以使用， 和到哪里去取。</p>
<p>第二步， 通过 SqISessionFactory 创建一个 SqlSession。</p>
<p>问题：SqlSession 上面定义了各种增删改查的 AP|，是给客户端调用的。 返回了什么实现类？除了 SqlSession, 还创建了什么对象， 创建了什么环境？</p>
<p>第三步， 获得一个 Mapper 对象。</p>
<p>问题：Mapper 是一个接口， 没有实现类， 是不能被实例化的， 那获取到的这个Mapper 对象是什么对象？为什么要从 SqlSession 里面去获取？为什么传进去一个接口， 然后还要用接口类型来接收？</p>
<p>第四步， 调用接口方法。</p>
<p>问题：我们的接口没有创建实现类， 为什么可以调用它的方法？那它调用的是什么方法？</p>
<p>这一步实际做的事情是执行 SQL, 那它又是根据什么找到 XML 映射器里面的 SQL的？ 此外， 我们的方法参数（对象或者 Map) 是怎么转换成 SQL 参数的？获取到的结果集是怎么转换成对象的？</p>
<p>最后一步， 关闭 session, 这步是必须要做的。</p>
<a id="more"></a>


<h3 id="一-配置解析过程"><a href="#一-配置解析过程" class="headerlink" title="一  配置解析过程"></a>一  配置解析过程</h3><p>首先我们要清楚的是配置解析的过程全部只解析了两种文件。一个是mybatis-config.xml 全局配置文件。 另外就是所有的 Mapper.xml 文件， 也包括在Mapper 接口类上面定义的注解。</p>
<p>我们从 mybatis-config.xml 开始。 看一下这里面的标签都是怎么解析的， 解析的时候做了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>

<p>首先我们new 了一个 SqlSessionFactoryBuilder, 这是建造者模式的运用（建造者模式用来创建复杂对象，而不需要关注内部细节， 是一种封装的体现）。 MyBatis 中很多地方用到了建造者模式（名字以Builder 结尾的类还有9 个）。</p>
<p>SqISessionFactoryBuiIder 中用来创建 SqlSessionFactory 对象的方法是 build(),build(）方法有 9 个重载， 可以用不同的方式来创建 SqlSessionFactory 对象 。SqlSessionFactory 对象默认是单例的。</p>
<ul>
<li>XMLConfigBuilder</li>
</ul>
<p>这里面创建了一个 XMLConfigBuiIder 对象（用来存放所有配置信息的Configuration 对象也是这个时候创建的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br></pre></td></tr></table></figure>

<p>XMLConfigBuilder 是抽象类 BaseBuilder 的一个子类， 专门用来解析全局配置文件，针对不同的构建目标还有其他的一些子类， 比如：</p>
<p>XMLConfigBuilder: 解析全局配置文件</p>
<p>MapperAnnotationBuilder:注解的解析</p>
<p>XMLMapperBuilder:解析Mapper.xml映射文件</p>
<p>XMLStatementBuilder：解析增删改查标签</p>
<p>XMLScriptBuilder: 解析动态 SQL</p>
<p><img src="https://i.loli.net/2020/05/14/2s5P18pHcyNwFRT.png" alt="image.png"></p>
<p>根据我们解析的文件流， 这里后面两个参数都是空的， 创建了一个 parser。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">     <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       inputStream.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里有两步， 第一步是调用 parser 的 parse(）方法， 它会返回一个 Configuration类,配置文件里面所有的信息都会放在 Configuration 里面。mapper.xml中<configuration> 的子标签跟 Configuration 类的属性是直接对应的。</p>
<p>我们先看一下 parse(）方法：</p>
<p>首先会检查全局配置文件是不是已经解析过， 也就是说在应用的生命周期里面config 配置文件只需要解析一次， 生成的 Configuration 对象也会存在应用的整个生命周期中。</p>
<p>接下来就是 parseConfiguration 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析根标签&lt;configuration&gt;</span></span><br><span class="line">parseConfiguration(parser. <span class="function">evalN <span class="title">ode</span><span class="params">(<span class="string">"/configuration"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>解析 XML 有很多方法， MyBatis 对 dom 和SAX做了封装， 方便使用。这下面有十几个方法， 对应着 config 文件里面的所有一级标签。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题： MyBatis 全局配置文件中标签的顺序可以颠倒吗？比如把 settings 放在plugins 之后？会报错。 所以顺序必须严格一致。</p>
<p><img src="https://i.loli.net/2020/05/14/Tf5rOAkC2jvUSXz.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.对于全局配置文件各种标签的解析</span></span><br><span class="line">propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br></pre></td></tr></table></figure>

<p>第一个是解析 <properties> 标签，读取我们引入的外部配置文件，例如db.properties。这里面又有两种类型，—种是放在 resource 目录下的，是相对路径，—种是写的绝对路径 的 (url) 。</p>
<p>解析 的 最终结果就是我们会把所有 的配置信息放到名为 defaults 的 Properties 对象里面 (Hashtable 对象，KV 存储），最后把 XPathParser和 Configuration 的 Properties属性都 设置成我们填充后的 Properties 对象。    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XPathParser.setVariables(defaults);</span><br><span class="line">Configuration.setVariables(defaults);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.解析 settings 标签</span></span><br><span class="line"> Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br></pre></td></tr></table></figure>

<p>第二个，我们把 <settings> 标签也解析成了一个 Properties 对象，对于<settings>标签的子标签的处理在后面（先解析，后设置） 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadCustomVfs(settings)</span><br></pre></td></tr></table></figure>

<p>loadCustomVfs 是获取 Vitual File System 的自定义实现类，比如要读取本地文件，或者 FTP 远程文件的时候， 就可以用到自定义的 VFS 类。</p>
<p>根据 <settings>标签里面的 &lt;vfslmp|&gt;标签， 生成了一个抽象类 VFS 的子类， 在MyBatis 中有 JBoss6VFS 和 DefaultVFS 两个实现， 在 io 包中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends VFS&gt; vfslmpl = (Class&lt;? extends VFS&gt;)Resources.classForName(clazz); configuration.setVfslmpl(vfslmpl);</span><br></pre></td></tr></table></figure>

<p>最后赋值到 Configuration 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loadCustomloglmpl(settings)</span><br></pre></td></tr></table></figure>

<p>loadCustomloglmpl是根据&lt;loglmpl＞标签获取日志的实现类，我们可以用到很多的日志的方案， 包括 LOG4J, LOG4J2, SLF4J 等等，在logging 包中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;? extends Log&gt; loglmpl = resolveClass(props.getProperty(<span class="string">"loglmpl"</span>)); </span><br><span class="line">configuration.setLoglmpl(loglmpl);</span><br></pre></td></tr></table></figure>

<p> 这里生成了一个 Log 接口的实现类， 并且赋值到 Configuration 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.类型别名</span></span><br><span class="line">typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br></pre></td></tr></table></figure>

<p>这一步解析的是类型别名。它有两种定义方式，一种是直接定义一个类的别名（例如 com.domain.Blog 定义成 blog),另一种就是指定一个 package，那么这个包下面所有的类的名字就会成为这个类全路径的别名。</p>
<p>类的别名和类的关系， 我们放在—个 TypeAliasRegistry 对象里面。其实就是一个Map&lt;String, Class&lt;?&gt;&gt; typeAliases</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 放入 TypeAliasRegistry</span></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">              String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">              configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              String alias = child.getStringAttribute(<span class="string">"alias"</span>);</span><br><span class="line">              String type = child.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">                <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; typeAliases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TypeAliasRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerAlias(<span class="string">"string"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"byte"</span>, Byte<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"long"</span>, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"short"</span>, Short<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"int"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"integer"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"double"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"float"</span>, Float<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"boolean"</span>, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"byte[]"</span>, Byte[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"long[]"</span>, Long[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"short[]"</span>, Short[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"int[]"</span>, Integer[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"integer[]"</span>, Integer[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"double[]"</span>, Double[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"float[]"</span>, Float[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"boolean[]"</span>, Boolean[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"_byte"</span>, <span class="keyword">byte</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_long"</span>, <span class="keyword">long</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_short"</span>, <span class="keyword">short</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_int"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_integer"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_double"</span>, <span class="keyword">double</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_float"</span>, <span class="keyword">float</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_boolean"</span>, <span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"_byte[]"</span>, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_long[]"</span>, <span class="keyword">long</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_short[]"</span>, <span class="keyword">short</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_int[]"</span>, <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_integer[]"</span>, <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_double[]"</span>, <span class="keyword">double</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_float[]"</span>, <span class="keyword">float</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"_boolean[]"</span>, <span class="keyword">boolean</span>[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"date"</span>, Date<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"decimal"</span>, BigDecimal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"bigdecimal"</span>, BigDecimal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"biginteger"</span>, BigInteger<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"object"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"date[]"</span>, Date[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"decimal[]"</span>, BigDecimal[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"bigdecimal[]"</span>, BigDecimal[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"biginteger[]"</span>, BigInteger[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"object[]"</span>, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"map"</span>, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"hashmap"</span>, HashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"list"</span>, List<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"arraylist"</span>, ArrayList<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"collection"</span>, Collection<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    registerAlias(<span class="string">"iterator"</span>, Iterator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    registerAlias(<span class="string">"ResultSet"</span>, ResultSet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.插件,完成第一步插件的配置的解析工作</span></span><br><span class="line">pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br></pre></td></tr></table></figure>

<p>接下来就是解析&lt; plugins&gt;标签，比如 Pagehelper 的翻页插件，或者我们自定义的插件。<plugins>标签里面只有<plugin>标签， <plugin>标签里面只有&lt; property&gt;标</p>
<p>因为所有的插件都要实现 Interceptor 接口，所以这—步做的事情就是把插件解析成Interceptor 类，设置属性，然后添加到 Configuration 的 lnterceptorChain 属性里面，它是—个List<Interceptor> interceptors。这里用到了责任链模式,多个拦截器组成起来就是责任链了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance = (Interceptor) 		                                       resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptorChain.addInterceptor(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意， 插件的工作流程分成三步， 第—步解析， 第二步包装（代理）， 第三步运行时拦截。 这里完成了第—步的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.用于创建对象,对反射结果集的封装,将我们查询的结果集快速转换成实体对象</span></span><br><span class="line">objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line"><span class="comment">// 用于对对象进行加工</span></span><br><span class="line">objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line"><span class="comment">// 反射工具箱</span></span><br><span class="line">reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br></pre></td></tr></table></figure>

<p>ObjectFactory 用来创建返回的对象。</p>
<p>objectWrapperFactory用来对对象做特殊的处理。 比如： select 没有写别名， 查询返回的是一个 Map, 可以在自定义的 objectWrapperFactory 中把下划线命名变成驼峰命名。</p>
<p>ReflectorFactory 是反射的工具箱， 对反射的操作进行了封装（官网和文档没有这个对象的描述）。</p>
<p>以上四个对象， 都是用 resolveClass 创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.解析插件</span></span><br><span class="line">Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="comment">//2.解析ObjectFactory</span></span><br><span class="line">ObjectFactory factory = (ObjectFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="comment">//3.解析objectWrapperFactory</span></span><br><span class="line">ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="comment">//4.解析ReflectorFactory </span></span><br><span class="line">ReflectorFactory factory = (ReflectorFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.settings 子标签赋值，默认值就是在这里提供的 &gt;&gt;</span></span><br><span class="line">settingsElement(settings);</span><br></pre></td></tr></table></figure>

<p>这里就是对<settings>标签里面所有子标签的处理了， 前面我们已经把子标签全部转换成了 Properties 对象， 所以在这里处理 Properties 对象就可以了。</p>
<p>settings 二级标签中一共 26 个配置，比如二级缓存、 延迟加载、 默认执行器类型等</p>
<p>需要注意的是， 我们之前提到的所有的默认值， 都是在这里赋值的。 如果说后面我们不知道这个属性的值是什么， 也可以到这一步来确认下。并且所有的值， 都会赋值到 Configuration 的属性里面去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">settingsElement</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">"autoMappingBehavior"</span>, <span class="string">"PARTIAL"</span>)));</span><br><span class="line">    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">"autoMappingUnknownColumnBehavior"</span>, <span class="string">"NONE"</span>)));</span><br><span class="line">    configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">"cacheEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">"proxyFactory"</span>)));</span><br><span class="line">    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">"lazyLoadingEnabled"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(<span class="string">"aggressiveLazyLoading"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(<span class="string">"multipleResultSetsEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(<span class="string">"useColumnLabel"</span>), <span class="keyword">true</span>));</span><br><span class="line">    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(<span class="string">"useGeneratedKeys"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(<span class="string">"defaultExecutorType"</span>, <span class="string">"SIMPLE"</span>)));</span><br><span class="line">    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(<span class="string">"defaultStatementTimeout"</span>), <span class="keyword">null</span>));</span><br><span class="line">    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(<span class="string">"defaultFetchSize"</span>), <span class="keyword">null</span>));</span><br><span class="line">    configuration.setDefaultResultSetType(resolveResultSetType(props.getProperty(<span class="string">"defaultResultSetType"</span>)));</span><br><span class="line">    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(<span class="string">"mapUnderscoreToCamelCase"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(<span class="string">"safeRowBoundsEnabled"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(<span class="string">"localCacheScope"</span>, <span class="string">"SESSION"</span>)));</span><br><span class="line">    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(<span class="string">"jdbcTypeForNull"</span>, <span class="string">"OTHER"</span>)));</span><br><span class="line">    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(<span class="string">"lazyLoadTriggerMethods"</span>), <span class="string">"equals,clone,hashCode,toString"</span>));</span><br><span class="line">    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(<span class="string">"safeResultHandlerEnabled"</span>), <span class="keyword">true</span>));</span><br><span class="line">    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(<span class="string">"defaultScriptingLanguage"</span>)));</span><br><span class="line">    configuration.setDefaultEnumTypeHandler(resolveClass(props.getProperty(<span class="string">"defaultEnumTypeHandler"</span>)));</span><br><span class="line">    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(<span class="string">"callSettersOnNulls"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setUseActualParamName(booleanValueOf(props.getProperty(<span class="string">"useActualParamName"</span>), <span class="keyword">true</span>));</span><br><span class="line">    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(<span class="string">"returnInstanceForEmptyRow"</span>), <span class="keyword">false</span>));</span><br><span class="line">    configuration.setLogPrefix(props.getProperty(<span class="string">"logPrefix"</span>));</span><br><span class="line">    configuration.setConfigurationFactory(resolveClass(props.getProperty(<span class="string">"configurationFactory"</span>)));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 7.创建了数据源 &gt;&gt;</span></span><br><span class="line">environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br></pre></td></tr></table></figure>

<p>这一步是解析<environments>标签。一个 environment 就是对应一个数据源， 所以在这里我们会根据配置的<transactionManager>创建一个事务工厂，根据<dataSource>标签创建一个数据源最后把这两个对象设置成Environment对象的属性，放到Configuration里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        environment = context.getStringAttribute(<span class="string">"default"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">        String id = child.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">          <span class="comment">// 事务工厂</span></span><br><span class="line">          TransactionFactory txFactory = transactionManagerElement(child.evalNode(<span class="string">"transactionManager"</span>));</span><br><span class="line">          <span class="comment">// 数据源工厂（例如 DruidDataSourceFactory ）</span></span><br><span class="line">          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(<span class="string">"dataSource"</span>));</span><br><span class="line">          <span class="comment">// 数据源</span></span><br><span class="line">          DataSource dataSource = dsFactory.getDataSource();</span><br><span class="line">          <span class="comment">// 包含了 事务工厂和数据源的 Environment</span></span><br><span class="line">          Environment.Builder environmentBuilder = <span class="keyword">new</span> Environment.Builder(id)</span><br><span class="line">              .transactionFactory(txFactory)</span><br><span class="line">              .dataSource(dataSource);</span><br><span class="line">          <span class="comment">// 放入 Configuration</span></span><br><span class="line">          configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8.设置不同的数据方言,例如:mysql,oracle</span></span><br><span class="line">databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br></pre></td></tr></table></figure>

<p>解析 databaseldProvider标签，生成DatabaseldProvider对象（用来支持不同厂商的数据库）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//9.typeHandler 数据库字段类型和java中属性类型的映射</span></span><br><span class="line">typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br></pre></td></tr></table></figure>

<p>跟TypeAlias一样，TypeHandler有两种配置方式，—种是单独配置一个类，—种是指定一个package。 最后我们得到的是JavaType和JdbcType, 以及用来做相互映射的TypeHandler之间的映射关系，存放在TypeHandlerRegistry对象里面。</p>
<p>我们可以通过不同数据的场景,继承BaseTypeHandler<T>自定义映射类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeHandlerRegistry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">          Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);</span><br><span class="line">          <span class="keyword">if</span> (map == <span class="keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="comment">//GXTypeHandler extends BaseTypeHandler&lt;List&lt;String&gt;&gt;</span></span><br><span class="line">          map.put(jdbcType, handler);</span><br><span class="line">           <span class="comment">//jdbc类型和java属性类型的映射</span></span><br><span class="line">          typeHandlerMap.put(javaType, map);</span><br><span class="line">        &#125;</span><br><span class="line">        allTypeHandlersMap.put(handler.getClass(), handler);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>问题：这种三个对象(Java类型，JDBC类型，Handler)的关系怎么映射？ （Map里面再放一个Map)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10.解析引用的Mapper映射器,即sql语句解析</span></span><br><span class="line">   mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br></pre></td></tr></table></figure>

<p>根据全局配置文件中不同的注册方式， 用不同的方式扫描， 但最终都是做了两件事情， 对于语句的注册和接口的注册。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">// 不同的定义方式的扫描，最终都是调用 addMapper()方法（添加到 MapperRegistry）。这个方法和 getMapper() 对应</span></span><br><span class="line">        <span class="comment">// package	包</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// resource	相对路径</span></span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            <span class="comment">// 解析 Mapper.xml，总体上做了两件事情 &gt;&gt;</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// url	绝对路径</span></span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// class 	单个接口</span></span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>先从解析Mapper.xml的mapperParser.parse()方法入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 总体上做了两件事情，对于语句的注册和接口的注册</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 1、具体增删改查标签的解析。</span></span><br><span class="line">      <span class="comment">// 一个标签一个MappedStatement。 &gt;&gt;</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      <span class="comment">// 2、把namespace（接口类型）和工厂类绑定起来，放到一个map。</span></span><br><span class="line">      <span class="comment">// 一个namespace 一个 MapperProxyFactory &gt;&gt;</span></span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>1、具体增删改查标签的解析。 一个标签一个MappedStatement。 </p>
<ul>
<li><p>configurationElement(parser.evalNode(“/mapper”));</p>
<p>在buildStatementFromContext(）方法中， 创建了用来解析增删改查标签的XM LStatementBuilder,并且把创建的MappedStatement添加到mapped Statements中。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLMapperBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant builderAssistant;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">              <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">              <span class="comment">// 添加缓存对象</span></span><br><span class="line">              cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">              <span class="comment">// 解析 cache 属性，添加缓存对象</span></span><br><span class="line">              cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">              <span class="comment">// 创建 ParameterMapping 对象</span></span><br><span class="line">              parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">              <span class="comment">// 创建 List&lt;ResultMapping&gt;</span></span><br><span class="line">              resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">              <span class="comment">// 解析可以复用的SQL</span></span><br><span class="line">              sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">              <span class="comment">// 解析增删改查标签，得到 MappedStatement &gt;&gt;</span></span><br><span class="line">              buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">              <span class="comment">// 用来解析增删改查标签的 XMLStatementBuilder</span></span><br><span class="line">              <span class="keyword">final</span> XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解析 Statement，添加 MappedStatement 对象 &gt;&gt;</span></span><br><span class="line">                statementParser.parseStatementNode();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">                configuration.addIncompleteStatement(statementParser);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLStatementBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperBuilderAssistant builderAssistant;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String nodeName = context.getNode().getNodeName();</span><br><span class="line">        SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">        <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">        <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">        <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">        <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">        XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">        includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">        String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">        Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">        String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">        LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">        processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">        KeyGenerator keyGenerator;</span><br><span class="line">        String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">        keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">          keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          keyGenerator = context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">              configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">              ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">        StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">        Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">        Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">        String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">        String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">        Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">        String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">        String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">        ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">        <span class="keyword">if</span> (resultSetTypeEnum == <span class="keyword">null</span>) &#123;</span><br><span class="line">          resultSetTypeEnum = configuration.getDefaultResultSetType();</span><br><span class="line">        &#125;</span><br><span class="line">        String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">        String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">        String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt; 关键的一步： MappedStatement 的创建</span></span><br><span class="line">        builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,</span><br><span class="line">            fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">            resultSetTypeEnum, flushCache, useCache, resultOrdered,</span><br><span class="line">            keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String id,</span></span></span><br><span class="line"><span class="function"><span class="params">      SqlSource sqlSource,</span></span></span><br><span class="line"><span class="function"><span class="params">      StatementType statementType,</span></span></span><br><span class="line"><span class="function"><span class="params">      SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="function"><span class="params">      Integer fetchSize,</span></span></span><br><span class="line"><span class="function"><span class="params">      Integer timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      String parameterMap,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="function"><span class="params">      String resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="function"><span class="params">      KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">      String keyProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">      String keyColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">      String databaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">      LanguageDriver lang,</span></span></span><br><span class="line"><span class="function"><span class="params">      String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Cache-ref not yet resolved"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    MappedStatement.Builder statementBuilder = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource)</span><br><span class="line">        .fetchSize(fetchSize)</span><br><span class="line">        .timeout(timeout)</span><br><span class="line">        .statementType(statementType)</span><br><span class="line">        .keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty)</span><br><span class="line">        .keyColumn(keyColumn)</span><br><span class="line">        .databaseId(databaseId)</span><br><span class="line">        .lang(lang)</span><br><span class="line">        .resultOrdered(resultOrdered)</span><br><span class="line">        .resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .resultSetType(resultSetType)</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">      statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    <span class="comment">// 最关键的一步，在 Configuration 添加了 MappedStatement &gt;&gt;</span></span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	对应的是 Mapper.xml 里面的一个增删改查的标签</span></span><br><span class="line"><span class="comment">    参数类型，结果类型，SQL，方法属性都在这这对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedStatement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String resource;</span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Integer fetchSize;</span><br><span class="line">  <span class="keyword">private</span> Integer timeout;</span><br><span class="line">  <span class="keyword">private</span> StatementType statementType;</span><br><span class="line">  <span class="keyword">private</span> ResultSetType resultSetType;</span><br><span class="line">  <span class="keyword">private</span> SqlSource sqlSource;<span class="comment">//sql语句封装在这里</span></span><br><span class="line">  <span class="keyword">private</span> Cache cache;</span><br><span class="line">  <span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line">  <span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;<span class="comment">//结果集封装</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line">  <span class="keyword">private</span> SqlCommandType sqlCommandType;</span><br><span class="line">  <span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line">  <span class="keyword">private</span> String[] keyProperties;</span><br><span class="line">  <span class="keyword">private</span> String[] keyColumns;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">  <span class="keyword">private</span> String databaseId;</span><br><span class="line">  <span class="keyword">private</span> Log statementLog;</span><br><span class="line">  <span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line">  <span class="keyword">private</span> String[] resultSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、把namespace（接口类型）和工厂类绑定起来，放到一个map。一个namespace 一个 MapperProxyFactory </p>
<ul>
<li><p>bindMapperForNamespace();</p>
<p>主要是是调用了configuration. addMapper(boundType); 在addMapper(）方法中， 把接口类型注册到MapperRegistry中：实际上是为接口创建一个对应的 MapperProxyFactory（用于为这个type提供工厂类， 创建MapperProxy) 。 </p>
<p>knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        boundType = Resources.classForName(namespace);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">          configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">          <span class="comment">// 添加到 MapperRegistry，本质是一个 map，里面也有 Configuration &gt;&gt;</span></span><br><span class="line">          configuration.addMapper(boundType);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//type: mapper接口的class</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ！Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; 存放的是接口类型，和对应的工厂类的关系</span></span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">            <span class="comment">// 注册了接口之后，根据接口，开始解析所有方法上的注解，例如 @Select &gt;&gt;</span></span><br><span class="line">            MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">              knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册了接 口之后， 开始解析接口类和所有方法上的注解, 例如:@CacheNamespace,@Select。此处创建了一个MapperAnnotationBuilder专门用来解析 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ！Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; 存放的是接口类型，和对应的工厂类的关系</span></span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        <span class="comment">// 注册了接口之后，根据接口，开始解析所有方法上的注解，例如 @Select &gt;&gt;</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>parse(）方法中 的parseCache(）和parseCacheRef(）方法其实是 对@CacheNamespace和＠CacheNamespaceRef这两个 注解的处理。</p>
<p>parseStatement(）方法里面的各种getAnnotation(）， 都是对相应的注解的解析比如＠Options, @SelectKey, @ResultMap等等。</p>
<p>最后同样会创建MappedStatement对象， 添加到MapperRegistry中。 也就是说在 XML中配置， 和使用注解配置，最后起到一样的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String resource = type.toString();</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      <span class="comment">// 先判断 Mapper.xml 有没有解析，没有的话先解析 Mapper.xml（例如定义 package 方式）</span></span><br><span class="line">      loadXmlResource();</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      assistant.setCurrentNamespace(type.getName());</span><br><span class="line">      <span class="comment">// 处理 @CacheNamespace</span></span><br><span class="line">      parseCache();</span><br><span class="line">      <span class="comment">// 处理 @CacheNamespaceRef</span></span><br><span class="line">      parseCacheRef();</span><br><span class="line">      <span class="comment">// 获取所有方法</span></span><br><span class="line">      Method[] methods = type.getMethods();</span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// issue #237</span></span><br><span class="line">          <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">            <span class="comment">// 解析方法上的注解，添加到 MappedStatement 集合中 &gt;&gt;</span></span><br><span class="line">            parseStatement(method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">          configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parsePendingMethods();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = getParameterType(method);</span><br><span class="line">    LanguageDriver languageDriver = getLanguageDriver(method);</span><br><span class="line">    <span class="comment">// 从方法上获取 SQL</span></span><br><span class="line">    SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">    <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Options 可以设置缓存、自增主键等</span></span><br><span class="line">      Options options = method.getAnnotation(Options<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">final</span> String mappedStatementId = type.getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">      Integer fetchSize = <span class="keyword">null</span>;</span><br><span class="line">      Integer timeout = <span class="keyword">null</span>;</span><br><span class="line">      StatementType statementType = StatementType.PREPARED;</span><br><span class="line">      ResultSetType resultSetType = configuration.getDefaultResultSetType();</span><br><span class="line">      SqlCommandType sqlCommandType = getSqlCommandType(method);</span><br><span class="line">      <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">      <span class="keyword">boolean</span> flushCache = !isSelect;</span><br><span class="line">      <span class="keyword">boolean</span> useCache = isSelect;</span><br><span class="line"></span><br><span class="line">      KeyGenerator keyGenerator;</span><br><span class="line">      String keyProperty = <span class="keyword">null</span>;</span><br><span class="line">      String keyColumn = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) &#123;</span><br><span class="line">        <span class="comment">// first check for SelectKey annotation - that overrides everything else</span></span><br><span class="line">        <span class="comment">// @SelectKey 返回该条记录的主键</span></span><br><span class="line">        SelectKey selectKey = method.getAnnotation(SelectKey<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">          keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);</span><br><span class="line">          keyProperty = selectKey.keyProperty();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</span><br><span class="line">          keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">          keyProperty = options.keyProperty();</span><br><span class="line">          keyColumn = options.keyColumn();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        keyGenerator = NoKeyGenerator.INSTANCE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FlushCachePolicy.TRUE.equals(options.flushCache())) &#123;</span><br><span class="line">          flushCache = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FlushCachePolicy.FALSE.equals(options.flushCache())) &#123;</span><br><span class="line">          flushCache = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        useCache = options.useCache();</span><br><span class="line">        fetchSize = options.fetchSize() &gt; -<span class="number">1</span> || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : <span class="keyword">null</span>; <span class="comment">//issue #348</span></span><br><span class="line">        timeout = options.timeout() &gt; -<span class="number">1</span> ? options.timeout() : <span class="keyword">null</span>;</span><br><span class="line">        statementType = options.statementType();</span><br><span class="line">        <span class="keyword">if</span> (options.resultSetType() != ResultSetType.DEFAULT) &#123;</span><br><span class="line">          resultSetType = options.resultSetType();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String resultMapId = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// @ResultMap 定义返回值</span></span><br><span class="line">      ResultMap resultMapAnnotation = method.getAnnotation(ResultMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">if</span> (resultMapAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        resultMapId = String.join(<span class="string">","</span>, resultMapAnnotation.value());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSelect) &#123;</span><br><span class="line">        resultMapId = parseResultMap(method);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 最后 增删改查标签 也要添加到 MappedStatement 集合中</span></span><br><span class="line">      assistant.addMappedStatement(</span><br><span class="line">          mappedStatementId,</span><br><span class="line">          sqlSource,</span><br><span class="line">          statementType,</span><br><span class="line">          sqlCommandType,</span><br><span class="line">          fetchSize,</span><br><span class="line">          timeout,</span><br><span class="line">          <span class="comment">// ParameterMapID</span></span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          parameterTypeClass,</span><br><span class="line">          resultMapId,</span><br><span class="line">          getReturnType(method),</span><br><span class="line">          resultSetType,</span><br><span class="line">          flushCache,</span><br><span class="line">          useCache,</span><br><span class="line">          <span class="comment">// TODO gcode issue #577</span></span><br><span class="line">          <span class="keyword">false</span>,</span><br><span class="line">          keyGenerator,</span><br><span class="line">          keyProperty,</span><br><span class="line">          keyColumn,</span><br><span class="line">          <span class="comment">// DatabaseID</span></span><br><span class="line">          <span class="keyword">null</span>,</span><br><span class="line">          languageDriver,</span><br><span class="line">          <span class="comment">// ResultSets</span></span><br><span class="line">          options != <span class="keyword">null</span> ? nullOrEmpty(options.resultSets()) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>build()</p>
<p>Mapper.xml解析完之后， 调用另一个build(）方法， 返回SqlSessionFactory的默认实现类DefaultSqlSessionFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结: 在这一步,我们主要完成了config配置文件、 Mapper文件、 Mapper接口中注解的解析。我们得到了一个最重要的对象Configuration,这里面存放了全部的配置信息，它在属性里面还有各种各样的容器。</strong></p>
<p><strong>最后，返回了一个DefaultSqlSessionFactory,里面持有了Configuration的实例。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 用于解析 mybatis-config.xml，同时创建了 Configuration 对象 &gt;&gt;</span><br><span class="line">      XMLConfigBuilder parser &#x3D; new XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      &#x2F;&#x2F; 解析XML，最终返回一个 DefaultSqlSessionFactory &gt;&gt;</span><br><span class="line">      return build(parser.parse());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      try &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; Intentionally ignore. Prefer previous error.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public SqlSessionFactory build(Configuration config) &#123;</span><br><span class="line">    return new DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="二-会话创建过程"><a href="#二-会话创建过程" class="headerlink" title="二  会话创建过程"></a>二  会话创建过程</h1><p>程序每—次操作数据库， 都需要创建—个会话， 我们用openSession(）方法来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>

<p>这里用到了上一步创建的DefaultSqlSessionFactory,在openSessionFromDataSource(）方法中创建。</p>
<p>这个会话里面， 需要包含—个<strong>Executor</strong>用来执行SQL。 Executor又要指定事务类型和执行器的类型。</p>
<p>所以我们会先从Configuration里面拿到Enviroment, Enviroment里面就有事务</p>
<ul>
<li>1、 创建Transaction</li>
</ul>
<p>这里会从Environment对象中取出—个TransactionFactory, 它是解析<environments>标签的时候创建的。</p>
<p>如果是Spring + MyBatis , 则没有必要配 置,因为 我们 会直接在applicationContext.xml里面配置数据洞和事务管理器 ， 覆盖MyBatis的配置 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DefaultSqlSessionFactory implements SqlSessionFactory &#123;</span><br><span class="line"></span><br><span class="line">    private final Configuration configuration;</span><br><span class="line"></span><br><span class="line">    private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123;</span><br><span class="line">        Transaction tx &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">          final Environment environment &#x3D; configuration.getEnvironment();</span><br><span class="line">          &#x2F;&#x2F; 获取事务工厂</span><br><span class="line">          final TransactionFactory transactionFactory &#x3D; getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">          &#x2F;&#x2F; 创建事务</span><br><span class="line">          tx &#x3D; transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">          &#x2F;&#x2F; 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span><br><span class="line">          final Executor executor &#x3D; configuration.newExecutor(tx, execType);</span><br><span class="line">          return new DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          closeTransaction(tx); &#x2F;&#x2F; may have fetched a connection so lets call close()</span><br><span class="line">          throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、 创建Executor</li>
</ul>
<p>使用newExecutor方法创建：new DefaultSqlSession(configuration, executor, autoCommit);</p>
<p>可以细分成三步。</p>
<p>①.创建执行器</p>
<p>Executor 的基本类型有三种： SIMPLE,BATCH,REUSE, 默认是 SIMPLE,(settings Element(）读取默认值）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">   Executor executor;</span><br><span class="line">   <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">     executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">   <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">       <span class="comment">//对SimleExecutor的包装成二级缓存的执行器,使用到了包装器模式</span></span><br><span class="line">     executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">   executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">   <span class="keyword">return</span> executor;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>他们都继承了抽象类 BaseExecutor。 抽象类实现了 Executor 接口。</p>
<p><img src="https://i.loli.net/2020/05/14/QIsYUxFu61itCVR.png" alt="image.png"></p>
<p>为什么要让抽象类BaseExecutor实现Executor接口，然后让具体实现类继承抽象类?</p>
<p><strong>这是模板方法的体现。</strong></p>
<p>抽象方法是在子类中实现的， BaseExecutor 最终会调用到具体的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameter)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;BatchResult&gt; <span class="title">doFlushStatements</span><span class="params">(<span class="keyword">boolean</span> isRollback)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">doQueryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②.缓存装饰</p>
<p>如果cacheEnabled =true， 会用装饰器模式对executor进行装饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line"><span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">  executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③.插件代理</p>
<p>装饰完毕后，会执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br></pre></td></tr></table></figure>

<p>④.返回 SqI Session 实现类</p>
<p>最终返回DefaultSqlSession, 它的属性包括Configuration,Executor对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3、 总结</p>
<p>创建会话的过程，我们获得了一个DefaultSqlSession，里面包含了一个Executor,Executor是SQL的实际执行对象。</p>
</li>
</ul>
<h1 id="三-获取Mapper对象"><a href="#三-获取Mapper对象" class="headerlink" title="三  获取Mapper对象"></a>三  获取Mapper对象</h1><p>在旧版的MyBatis中，DefaultSqlSession的 selectOne(）方法可以直接根据Mapper.xml中的Statement ID, 找到SQL执行。但是这种方式属于硬编码， 我们没办法知道有多少处调用， 修改起来也很麻烦。</p>
<p>另一个问题是如果参数传入错误， 在编译阶段也是不会报错的， 不利于预先发现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog= (Blog) session.selectOne(<span class="string">"com.gupaoedu.mapper.BlogMapper.selectBlogByld"</span>, l);</span><br></pre></td></tr></table></figure>

<p>在 MyBatis 后期的版本提供了第二种调用方式， 就是定义一个接口然后再调用Mapper接口的方法。</p>
<p>由于我们的接口名称跟 Mapper.xml 的 namespace 是对应的， 接口的方法跟statement ID 也都是对应的， 所以根据方法就能找到对应的要执行的 SQL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这里有两个问题需要解决：</p>
<p>1.getMapper 获得的是一个什么对象？为什么可以执行它的方法？</p>
<p>2.到底是怎么根据 Mapper 找到 XML 中的 SQL 执行的？</p>
<ul>
<li>1、 getMapper()</li>
</ul>
<p>DefaultSqlSession 的 getMapper(）方法， 调用了 Configuration 的 getMapper()方法。</p>
<p>Configuration 的 getMapper(）方法， 又调用了 MapperRegistry 的 getMapper()</p>
<p>我们知道， 在解析 mapper 标签和 Mapper.xml 的时候已经把接口类型和类型对应的 MapperProxyFactory 放到了一个 Map 中。 获取 Mapper 代理对象， 实际上是从Map 中获取对应的工厂类后， 调用以下方法创建对象：</p>
<p>在 newlnstance(）方法中， 先创建 MapperProxy。</p>
<p>MapperProxy 实现了 lnvocationHandler 接口主要属性有三个：sqlSession、mapperlnterface,methodCache</p>
<p><img src="https://i.loli.net/2020/05/14/kTtMa64fu2n9gNK.png" alt="image.png"></p>
<p>最终通过 JDK 动态代理模式创建、 返回代理对象：</p>
<p>也就是说， getMapper(）返回的是—个 JDK 动态代理对象（类型是＄Proxy 数字）。</p>
<p>这个代理对象会继承 Proxy 类， 实现被代理的接口， 里面持有了—个 MapperProxy 类型的触发管理类。</p>
<p>前面的问题：为什么要在 MapperRegistry 中保存—个工厂类， 原来它是用来创建返回代理类的。</p>
<p>这里是代理模式的—个非常经典的应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"><span class="comment">//MapperRegistry就是存放了我们的接口namespace和mapperFactory的对应关系</span></span><br><span class="line"><span class="comment">//Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; 存放的是接口类型，和对应的工厂类的关系</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过jdk的动态代理获取代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, 		methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1：类加载器:2：被代理类实现的接口、3：实现了 InvocationHandler 的触发管理类</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[] &#123; 		mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是为什么要直接代理—个接口呢？</p>
<ul>
<li>2、 MapperProxy如何实现对接口的代理</li>
</ul>
<p>我们知道， JDK 的动态代理， 有三个核心角色：被代理类（实现类）、 接口、 实现了 lnvocationHandler 的触发管理类， 用来生成代理对象。</p>
<p>被代理类必须实现接口， 因为要通过接口获取方法， 而且代理类也要实现这个接口。</p>
<p><img src="https://i.loli.net/2020/05/14/jb69F4HXUZ1fosn.png" alt="image.png"></p>
<p>而 MyBatis 里面的 Mapper 没有实现类， 怎么被代理呢？它忽略了实现类， 直接对接口进行代理。</p>
<p>MyBatis 的动态代理：</p>
<p><img src="https://i.loli.net/2020/05/14/ji2esvT5VLAzCQq.png" alt="image.png">在MyBatis里面，动态代理为什么不需要实现类呢？</p>
<p>这里我们要想想我们的目的。我们的目的是根据一个可以执行的方法，直接找到Mapper.xml中的StatementID,方便调用。</p>
<p>如果根据接口类型＋方法的名称找到StatementID这个逻辑在Handler类(MapperProxy)中就可以完成，其实也就没有实现类的什么事了。</p>
<ul>
<li>3、总结</li>
</ul>
<p>获得Mapper对象的过程，实质上是获取了一个JDK动态代理对象（类型是＄Proxy数字）。这个代理类会继承Proxy类，实现被代理的接口，里面持有了一个MapperProxy类型的触发管理类。</p>
<h1 id="四-执行SQL"><a href="#四-执行SQL" class="headerlink" title="四  执行SQL"></a>四  执行SQL</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog= mapper.selectBlog(l);</span><br></pre></td></tr></table></figure>

<p>由于所有的 Mapper 都是 JDK 动态代理对象，所以任意的方法都是执行触发管理类MapperProxy的invoke(）方法。</p>
<p>问题 1 :我们引入 MapperProxy 为了解决什么问题？硬编码和编译时检查问题。它需要做的事情是：根据方法查找StatementID的问题。</p>
<p>问题 2：进入到 invoke 方法的时候做了什么事情？它是怎么找到我们要执行的 SQL的？</p>
<p>看—下invoke(）方法：</p>
<p>①.首先判断是否需要去执行SQL, 还是直接执行方法。 Object本身的方法不需要去执行SQL, 比如toString(）、 hashCode(）、 equals(）、 getClass(）。</p>
<p>②.获取缓存</p>
<p>这里加入缓存 是为了提升MapperMethod的获取速度。 很巧妙的设计。 缓存的使用在MyBatis中随处可见。</p>
<p>获取缓存， 保存了方法签名和接口方法的关系</p>
<p>Map的computelfAbsent(）方法：根据key 获取值 ， 如果值 是 null ， 则把后面Object 的值赋给key。</p>
<p>Java8 和 Java9中的接口默认方法有特殊处理， 返回DefaultMethodInvoker。</p>
<p>普通的方法 返回的是PlainMethodlnvoker, 返回 MapperMethod。</p>
<p>MapperMethod中有两个主要的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statement id （例如：com.gupaoedu.mapper.BlogMapper.selectBlogById） 和 SQL 类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line"><span class="comment">// 方法签名，主要是返回值的类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br></pre></td></tr></table></figure>

<p>一个是 SqlCommand , 封装了 statement ,（例 如：com.gupaoedu.mapper.BlogMapper.selectBlogByld) 和 SQL 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">      <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">      MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass,</span><br><span class="line">          configuration);</span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(Flush<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">          name = <span class="keyword">null</span>;</span><br><span class="line">          type = SqlCommandType.FLUSH;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Invalid bound statement (not found): "</span></span><br><span class="line">              + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        name = ms.getId();</span><br><span class="line">        type = ms.getSqlCommandType();</span><br><span class="line">        <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>一个是MethodSignature,主要是主要封装是返回值的类型。这两个属性都是MapperMethod的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSignature</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">      Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">      <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">      <span class="keyword">this</span>.returnsCursor = Cursor<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.returnsOptional = Optional<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">      <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行MapperProxy的invoke()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// toString hashCode equals getClass等方法，无需走到执行SQL的流程</span></span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 提升获取 mapperMethod 的效率，到 MapperMethodInvoker（内部接口） 的 invoke</span></span><br><span class="line">        <span class="comment">// 普通方法会走到 PlainMethodInvoker（内部类） 的 invoke</span></span><br><span class="line">        <span class="keyword">return</span> cachedInvoker(method).invoke(proxy, method, args, sqlSession);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethodInvoker <span class="title">cachedInvoker</span><span class="params">(Method method)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Java8 中 Map 的方法，根据 key 获取值，如果值是 null，则把后面Object 的值赋给 key</span></span><br><span class="line">      <span class="comment">// 如果获取不到，就创建</span></span><br><span class="line">      <span class="comment">// 获取的是 MapperMethodInvoker（接口） 对象，只有一个invoke方法</span></span><br><span class="line">      <span class="keyword">return</span> methodCache.computeIfAbsent(method, m -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.isDefault()) &#123;</span><br><span class="line">          <span class="comment">// 接口的默认方法(Java8)，只要实现接口都会继承接口的默认方法，例如 List.sort()</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (privateLookupInMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> DefaultMethodInvoker(getMethodHandleJava8(method));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> DefaultMethodInvoker(getMethodHandleJava9(method));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException | InvocationTargetException</span><br><span class="line">              | NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 创建了一个 MapperMethod</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PlainMethodInvoker(<span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">      Throwable cause = re.getCause();</span><br><span class="line">      <span class="keyword">throw</span> cause == <span class="keyword">null</span> ? re : cause;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainMethodInvoker</span> <span class="keyword">implements</span> <span class="title">MapperMethodInvoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperMethod mapperMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlainMethodInvoker</span><span class="params">(MapperMethod mapperMethod)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.mapperMethod = mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">// SQL执行的真正起点</span></span><br><span class="line">      <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、 MapperMethod.execute()</li>
</ul>
<p>另外 MapperMethod种定义了多种execute(）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args, SqlSession sqlSession)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">// SQL执行的真正起点</span></span><br><span class="line">      <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/15/BcI19xyCftp5G2l.png" alt="image.png"></p>
<p>在这一步步，根据不同的type(INSERT,UPDATE,DELETE,SELECT)和返回类型：</p>
<p>①.调用convertArgsToSqlCommandParam(）将方法参数转换为SQL的参数。</p>
<p>②.调用sqlSession的insert(),update(）,delete(）,selectOne (）方法。 我们以查询为例， 会走到selectOne(）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line"><span class="comment">// 普通 select 语句的执行入口 &gt;&gt;</span></span><br><span class="line">result = sqlSession.selectOne(command.getName(), param);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line">  <span class="comment">// statement id （例如：com.gupaoedu.mapper.BlogMapper.selectBlogById） 和 SQL 类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="comment">// 方法签名，主要是返回值的类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          <span class="comment">// 普通 select 语句的执行入口 &gt;&gt;</span></span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">              &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    re</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3、 DefaultSqlSession.selectOne()</p>
<p>这里来到了对外的接口的默认实现类DefaultSqlSession。selectOne(）最终也是调用了selectlist(）。</p>
<p>在Selectlist(）中，我们先根据command name (Statement ID)从Configuration中拿到MappedStatement。ms里面有xml中增删改查标签配置的所有属性，包括id,statementType,sqLSource,useCache,入参,出参等等。</p>
<p><img src="https://i.loli.net/2020/05/15/hON6c2kFTLaVgsb.png" alt="image.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSession</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 来到了 DefaultSqlSession</span></span><br><span class="line">    <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">this</span>.selectList(statement, parameter);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MappedStatemt:里面的一个增删改查的标签,参数类型，结果类型，SQL，方法属性都在这这对象中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//statement : com.gxedu.mapper.FeeMapper.selectByFeeDate namespace+方法名</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      <span class="comment">// 如果 cacheEnabled = true（默认），Executor会被 CachingExecutor装饰</span></span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行了Executor的query(）方法。</p>
<p>Executor是第二步openSession的时候创建的，创建了执行器基本类型之后，依次执行了二级缓存装饰， 和插件拦截。</p>
<p>所以， 如果有被插件拦截， 这里会先走到插件的逻辑。 如果没有显式地在 settings中配置 cacheEnabled =false， 再走到 CachingExecutor 的逻辑， 然后会走到Base Executor 的 query(）方法。</p>
<p>4、 CachingExecutor.query()</p>
<ul>
<li><p>①.创建CacheKey</p>
<p>二级缓存的 CacheKey 是怎么构成的呢？或者说， 什么样的查询才能确定是同一个查询呢？</p>
</li>
</ul>
<p>在 BaseExecutor 的 createCacheKey 方法中，用到了六个要素：</p>
<p><img src="https://i.loli.net/2020/05/15/ocO5GdBQ3WXHrwK.png" alt="image.png"></p>
<p>也就是说， 方法相同、 翻页偏移相同、 SQL 相同、 参数值相同、 数据源环境相同才会被认为是同一个查询。</p>
<p>CacheKey 的实际值举例 (toString(）生成的）， debug 可以看到：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">62997959</span>:<span class="string">7896198850:com.gxedu.mapper.FeeMapper.selectByFeeDate:0:2147483647:select id, fee_amt, fee_date from fee where DATE_FORMAT(fee_date,'%Y-%m-%d') = DATE_FORMAT(?,'%Y-%m-%d'):Wed Feb 26 00:00:00 CST 2020:development</span></span><br></pre></td></tr></table></figure>

<p>注意看一下 CacheKey 的属性， 里面有一个 List 按顺序存放了这些要素。</p>
<p>怎么比较两个 CacheKey是否相等呢？如果一上来就是依次比较六个要素是否相等，要比较 6 次，这样效率不高。 有没有更高效的方法呢？继承 Object 的每个类，都有一个<strong>hashCode (）</strong>方法， 用来生成哈希码。 <strong>它是用来在集合中快速判重的。</strong></p>
<p>在生成 CacheKey 的时候 (update 方法），也更新了 CacheKey 的 hashCode, 它是用乘法哈希生成的（基数 baseHashCode=17, 乘法因子 multiplier=37) 。</p>
<p>Object 中的 hashCode(）是一个本地方法， 通过随机数算法生成 (OpenJDK8, 默认， 可以通过－XX:hashCode 修改）。 CacheKey 中的 hashCode(）方法进行了重写， 返回自己生成的 hashCode。</p>
<p>为什么要用 37 作为乘法因子呢？跟 String 中的 31 类似。</p>
<p>CacheKey 中的 equals也进行了重写， 比较 CacheKey 是否相等。</p>
<p>如果哈希值（乘法哈希）、 校验值（加法哈希）、 要素个数任何一个不相等， 都不是同个查询， 最后才循环比较要素， 防止哈希碰撞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 获取SQL</span></span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">      <span class="comment">//创建CacheKey：什么样的SQL是同一条SQL？ &gt;&gt;</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">    <span class="comment">// cacheKey的结构:-1381545870:4796102018:com.gupaoedu.mapper.BlogMapper.selectBlogById:0:2147483647:select * from blog where bid = ?:1:development</span></span><br><span class="line">    cacheKey.update(ms.getId()); <span class="comment">// com.gupaoedu.mapper.BlogMapper.selectBlogById</span></span><br><span class="line">    cacheKey.update(rowBounds.getOffset()); <span class="comment">// 0</span></span><br><span class="line">    cacheKey.update(rowBounds.getLimit()); <span class="comment">// 2147483647 = 2^31-1</span></span><br><span class="line">    cacheKey.update(boundSql.getSql());</span><br><span class="line">    List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">    <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">    <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">          value = metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheKey.update(value); <span class="comment">// development</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// issue #176</span></span><br><span class="line">      cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> CacheKey()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Not allowed to update a null cache key instance."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Not allowed to update a null cache key instance."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//乘法因子</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLIER = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">//基数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//存放Cache属性的List集合</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLIER;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    updateAll(objects);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpdateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> updateList.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用update()</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加法哈希</span></span><br><span class="line">    <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line">    checksum += baseHashCode;</span><br><span class="line">    baseHashCode *= count;</span><br><span class="line">	<span class="comment">//乘法哈希+加法哈希得到最后的hashCode</span></span><br><span class="line">    hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line">	<span class="comment">//添加到List中</span></span><br><span class="line">    updateList.add(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAll</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : objects) &#123;</span><br><span class="line">      update(o);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 同一个对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被比较的对象不是 CacheKey</span></span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashcode 不相等</span></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// checksum 不相等</span></span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count 不相等</span></span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后遍历元素判断,防止哈希碰撞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//重写hashCode</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hashcode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringJoiner returnValue = <span class="keyword">new</span> StringJoiner(<span class="string">":"</span>);</span><br><span class="line">    returnValue.add(String.valueOf(hashcode));</span><br><span class="line">    returnValue.add(String.valueOf(checksum));</span><br><span class="line">    updateList.stream().map(ArrayUtil::toString).forEach(returnValue::add);</span><br><span class="line">    <span class="keyword">return</span> returnValue.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CacheKey <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    CacheKey clonedCacheKey = (CacheKey) <span class="keyword">super</span>.clone();</span><br><span class="line">    clonedCacheKey.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;(updateList);</span><br><span class="line">    <span class="keyword">return</span> clonedCacheKey;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheKey生成之后，调用另一个query(）方法。</p>
<ul>
<li>②.处理二级缓存</li>
</ul>
<p>首先从 ms 中取出 cache 对象， 判断 cache 对象是否为空， 如果为空， 则没有查询二级缓存、 写入二级缓存的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="comment">// cache 对象是在哪里创建的？  XMLMapperBuilder类 xmlconfigurationElement()</span></span><br><span class="line">    <span class="comment">// 由 &lt;cache&gt; 标签决定</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// flushCache="true" 清空一级二级缓存 &gt;&gt;</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="comment">//可以设置某个方法对数据的实时性要求很高,不需要二级缓存,使用userCahe标签,就可以单独关闭 &lt;select id="" resultMap="" userCahe="false"</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="comment">// 获取二级缓存</span></span><br><span class="line">        <span class="comment">// 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          <span class="comment">// 写入二级缓存</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到 SimpleExecutor | ReuseExecutor | BatchExecutor</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Cache对象是什么时候创建的呢？用来解析 Mapper.xml 的 XMLMapperBuilder 类， cacheElement(）方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cacheElement(context. evalNode(<span class="string">"cache"</span>));</span><br></pre></td></tr></table></figure>

<p>只有 Mapper.xml 中的<cache>标签不为空才解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">builderAssistant.useNewCache(typeClass, evictionClass, flushfuterval, size, readWrite, blocking, props);</span><br></pre></td></tr></table></figure>

<p>此处创建了一个 Cache 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setDefaultImplementations();</span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">cache</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">        cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">        setCacheProperties(cache);</span><br><span class="line">      &#125;</span><br><span class="line">      cache = setStandardDecorators(cache);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">cache</span>.<span class="title">getClass</span>())) </span>&#123;</span><br><span class="line">      cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以自行验证一下， 注释 <cache> ，是否不解析， cache 是否为 null。 开启<cache>，是否解析， cache 是否不为 null。</p>
<p>二级缓存为什么要用 TCM 来管理？思考一个问题在一个事务中：</p>
<p>1.首先插入一条数据（没有提交）， 此时二级缓存会被清空。</p>
<p>2.在这个事务中查询数据， 写入二级缓存。</p>
<p>3.提交事务， 出现异常， 数据回滚。</p>
<p>此时出现了数据库没有这条数据， 但是二级缓存有这条数据的情况。 所以 MyBatis的二级缓存需要跟事务关联起来。</p>
<p>疑问：为什么一级缓存不这么做？</p>
<p>因为一个 session 就是一个事务， 事务回滚， 会话就结束了， 缓存也清空了， 不存在读到一级缓存中脏数据的情况。 二级缓存是跨 session 的， 也就是跨事务的， 才有可能出现对同一个方法的不同事务访问。</p>
<ul>
<li><p>①.写入二级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入二级缓存</span></span><br><span class="line">tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br></pre></td></tr></table></figure>

<p>从 map 中拿出 TransactionalCache 对象，把 value 添加到待提交的 Map。此时缓存还没有真正地写入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">   <span class="comment">//将二级缓冲存储到待提交的Map中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object object)</span> </span>&#123;</span><br><span class="line">    entriesToAddOnCommit.put(key, object);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有事务提交的时候缓存才真正写入 (close 或者 commit 最后分析）。</p>
<p>②.获取二级缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取二级缓存</span></span><br><span class="line"><span class="comment">// 缓存通过 TransactionalCacheManager、TransactionalCache 管理</span></span><br><span class="line">List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    Object object = getTransactionalCache(cache).getObject(key);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 map 中拿出 Transa ct ion a IC ache 对象， 这个对象也是对 PerpetualCache 经过层层装饰的缓存对象：</p>
<p><img src="https://i.loli.net/2020/05/15/nroP1THVJ5YLlB8.png" alt="image.png"></p>
<p>得到再 getObject(）， 这个是个会递归调用的方法， 直到到达 PerpetualCache,拿到 value。</p>
</li>
</ul>
<p>5、 BaseExecutor.query()</p>
<ul>
<li><p>①.清空本地缓存</p>
<p>queryStack 用于记录查询栈， 防止递归查询重复处理缓存。</p>
</li>
</ul>
<p>flushCache=true 的时候， 会先清理本地缓存(—级缓存） ： </p>
<p>如果没有缓存， 会从数据库查询： queryFromDatabase()</p>
<p>如果 LocalCacheScope = = STATEMENT ， 会清理本地缓存。</p>
<ul>
<li><p>②.从数据库中查询</p>
<p>先在缓存用占位符占位。 执行查询后， 移除占位符， 放入数据。</p>
</li>
</ul>
<p>​      // 写入一级缓存    localCache.putObject(key, list);</p>
<p>执行 Executor 的 doQuery(）；默认是 SimpleExecutor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种 Executor 的区别，看doUpdate</span></span><br><span class="line"><span class="comment">// 默认Simple</span></span><br><span class="line">list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 异常体系之 ErrorContext</span></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      <span class="comment">// flushCache="true"时，即使是查询，也清空一级缓存</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 防止递归查询重复处理缓存</span></span><br><span class="line">      queryStack++;</span><br><span class="line">      <span class="comment">// 查询一级缓存</span></span><br><span class="line">      <span class="comment">// ResultHandler 和 ResultSetHandler的区别</span></span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的查询流程</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正查询数据库</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">// 先占位</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 三种 Executor 的区别，看doUpdate</span></span><br><span class="line">      <span class="comment">// 默认Simple</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 移除占位符</span></span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入一级缓存</span></span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>6、 SimpleExecutor.doQuery()</p>
<p>①.创建StatementHandler</p>
<p>在configuration.newStatementHandler(）中 ， new —个 StatementHandler, 先得到RoutingStatementHandler。</p>
<p>RoutingStatementHandler 里面没有任何的实现 ， 是用来创建基本的StatementHandler的。这里会根据MappedStatement里面的statementType决定StatementHandler 的类型。 默认是PREPARED (STATEMENT 、 PREPARED 、CALLABLE)。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"selectPerson"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterMap</span>=<span class="string">"deprecated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"hashmap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultMap</span>=<span class="string">"personResultMap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">"256"</span></span></span><br><span class="line">  &lt;!--可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement      或 CallableStatement，默认值：PREPARED。--&gt;</span><br><span class="line">  statementType="PREPARED"</span><br><span class="line">  resultSetType="FORWARD_ONLY"&gt;</span><br></pre></td></tr></table></figure>

<p><strong>StatementHandler</strong>里面包含了处理参数的<strong>ParameterHandler</strong>和处理结果集的<strong>ResultSetHandler</strong>。这两个对象都是在上面new的时候创建的。</p>
<p>这三个对象都是可以被插件拦截的四大对象之一，所以在创建之后都要用拦截器进行包装的方法 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statementHandler植入插件逻辑（返回代理对象）</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); </span><br><span class="line"><span class="comment">// parameterHandler植入插件逻辑（返回代理对象）</span></span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line"><span class="comment">// resultSetHandler植入插件逻辑（返回代理对象）</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br></pre></td></tr></table></figure>

<p>至此， 四大对象的包装已经全部完成。PS:四大对象还有一个是谁？在什么时候创建的？ （Executor)</p>
<p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li><p>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</p>
</li>
<li><p>ParameterHandler (getParameterObject, setParameters)</p>
</li>
<li><p>ResultSetHandler (handleResultSets, handleOutputParameters)</p>
</li>
<li><p>StatementHandler (prepare, parameterize, batch, update, query)</p>
<p>通 过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      flushStatements();</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">      Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">      stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">      handler.parameterize(stmt);</span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建StatementHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">* 实际上是用来选择具体的 StatementHandler 类型的</span></span><br><span class="line"><span class="comment"> * 持有了具体的 StatementHandler 的委托</span></span><br><span class="line"><span class="comment"> * 调用具体 StatementHandler 对象的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType="PREPARED"，默认值 PREPARED</span></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="comment">//Statement 每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.</span></span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        <span class="comment">// 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span></span><br><span class="line">        <span class="comment">//PreparedStatement是预编译的</span></span><br><span class="line">        <span class="comment">//a. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。</span></span><br><span class="line">        <span class="comment">// b. 安全性好，有效防止Sql注入等问题。</span></span><br><span class="line">        <span class="comment">// c.  对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；</span></span><br><span class="line">        <span class="comment">// d.  代码的可读性和可维护性。</span></span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。</span></span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SimpleStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过父类 BaseStatementHandler 的构造函数创建</span></span><br><span class="line">    <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ResultSetHandler resultSetHandler;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ParameterHandler parameterHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MappedStatement mappedStatement;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> RowBounds rowBounds;</span><br><span class="line">  <span class="keyword">protected</span> BoundSql boundSql;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了四大对象的其它两大对象 &gt;&gt;</span></span><br><span class="line">    <span class="comment">// 创建这两大对象的时候分别做了什么？</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ParameterHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler =                  mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ResultSetHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>②.创建Statement</p>
<p>用new出来的StatementHandler创建Statement对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      flushStatements();</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">      Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">      stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">      handler.parameterize(stmt);</span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果有插件包装， 会先走到被拦截的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stmt = handler.prepare(connection, transaction.getTimeout());</span><br></pre></td></tr></table></figure>

<p>prepareStatement(）方法对语句进行预编译， 处理参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handler.parameterize(stmt);</span><br></pre></td></tr></table></figure>

<p>这里面会调用parameterHandler设置参数， 如果有插件包装， 会先走到被拦截的业务逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void parameterize(Statement statement) throws SQLException &#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>执行的 StatementHandler 的 query(）方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handler.query(stmt, resultHandler);</span><br></pre></td></tr></table></figure>

<p>RoutingStatementHandler的query(）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.query(statement, resultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delegate委派 ， 最终执行PreparedStatementHandler的query(）方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PreparedStatementHandler extends BaseStatementHandler &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123;</span><br><span class="line">    PreparedStatement ps &#x3D; (PreparedStatement) statement;</span><br><span class="line">    &#x2F;&#x2F; 到了JDBC的流程</span><br><span class="line">    ps.execute();</span><br><span class="line">    &#x2F;&#x2F; 处理结果集</span><br><span class="line">    return resultSetHandler.handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④.执行 PreparedStatement 的 execute(）方法</p>
<p>后面就是JDBC包中的PreparedStatement的执行了。</p>
<p>⑤. ResultSetHandler 处理结果集</p>
<p>如果有插件包装， 会先走到被拦截的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br></pre></td></tr></table></figure>

<p>问题：怎么把 ResultSet转换成List<Object>?</p>
<p>ResultSetHandler只 有 —个实现类：DefaultResultSetHandler。 也就是执行DefaultResultSetHandler的handleResultSets (）方法。</p>
<p>首先我们会先拿到第—个结果集 ， 如果没有配置—个查询返回多个结果集的情况，一般只有—个结果集。 如果下面的这个while循环我们也不用， 就是执行—次。然后会调用handleResultSet(）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResultSetHandler</span> <span class="keyword">implements</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().activity(<span class="string">"handling results"</span>).object(mappedStatement.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">        ResultSetWrapper rsw = getFirstResultSet(stmt);</span><br><span class="line"></span><br><span class="line">        List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps();</span><br><span class="line">        <span class="keyword">int</span> resultMapCount = resultMaps.size();</span><br><span class="line">        validateResultMapsCount(rsw, resultMapCount);</span><br><span class="line">        <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultMapCount &gt; resultSetCount) &#123;</span><br><span class="line">          ResultMap resultMap = resultMaps.get(resultSetCount);</span><br><span class="line">          handleResultSet(rsw, resultMap, multipleResults, <span class="keyword">null</span>);</span><br><span class="line">          rsw = getNextResultSet(stmt);</span><br><span class="line">          cleanUpAfterHandlingResultSet();</span><br><span class="line">          resultSetCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] resultSets = mappedStatement.getResultSets();</span><br><span class="line">        <span class="keyword">if</span> (resultSets != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (rsw != <span class="keyword">null</span> &amp;&amp; resultSetCount &lt; resultSets.length) &#123;</span><br><span class="line">            ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);</span><br><span class="line">            <span class="keyword">if</span> (parentMapping != <span class="keyword">null</span>) &#123;</span><br><span class="line">              String nestedResultMapId = parentMapping.getNestedResultMapId();</span><br><span class="line">              ResultMap resultMap = configuration.getResultMap(nestedResultMapId);</span><br><span class="line">              handleResultSet(rsw, resultMap, <span class="keyword">null</span>, parentMapping);</span><br><span class="line">            &#125;</span><br><span class="line">            rsw = getNextResultSet(stmt);</span><br><span class="line">            cleanUpAfterHandlingResultSet();</span><br><span class="line">            resultSetCount++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">collapseSingleResultList</span><span class="params">(List&lt;Object&gt; multipleResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> multipleResults.size() == <span class="number">1</span> ? (List&lt;Object&gt;) multipleResults.get(<span class="number">0</span>) : multipleResults;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/15/XcFLmBlbxr72Ged.png" alt="image.png">)<img src="https://i.loli.net/2020/05/15/tw3KR45aevLkOjV.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>设计思想</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/gxblog/2020/04/28/synchronized-4%E6%9C%885%E6%97%A5/</url>
    <content><![CDATA[<h1 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h1><p>JDK早期，synchronized 叫做重量级锁， 因为申请锁资源必须通过kernel, 系统调用</p>
<p>重量级锁就是从用户态到内核态之间的一个调用</p>
<p>用户态:不需要惊动操作系统老大  </p>
<p>内核态:需要惊动操作系统老大,只用是处于用户态的都可以叫轻量级锁</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;hello.asm</span><br><span class="line">;write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line"></span><br><span class="line">section data</span><br><span class="line">    msg db &quot;Hello&quot;, 0xA</span><br><span class="line">    len equ $ - msg</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">    mov edx, len</span><br><span class="line">    mov ecx, msg</span><br><span class="line">    mov ebx, 1 ;文件描述符1 std_out</span><br><span class="line">    mov eax, 4 ;write函数系统调用号 4</span><br><span class="line">    int 0x80</span><br><span class="line"></span><br><span class="line">    mov ebx, 0</span><br><span class="line">    mov eax, 1 ;exit函数系统调用号</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5C17361%5CAppData%5CLocal%5CTemp%5C1586180012087.png" alt="1586180012087"></p>
<p>首先是偏向锁,其次是轻量级锁,最后是重量级锁</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p><img src="C:%5CUsers%5C17361%5CAppData%5CLocal%5CTemp%5C1586180175054.png" alt="1586180175054"></p>
<p>Compare And Swap (Compare And Exchange) / 自旋 / 自旋锁 / 无锁 （无重量锁）</p>
<p>因为经常配合循环操作，直到完成为止，所以泛指一类操作</p>
<p>cas(v, a, b) ，变量v，期待值a, 修改值b</p>
<p>ABA问题，你的女朋友在离开你的这段儿时间经历了别的人，自旋就是你空转等待，一直等到她接纳你为止</p>
<p>解决办法（版本号 AtomicStampedReference），基础类型简单值不需要版本号</p>
<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>AtomicInteger:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = get();</span><br><span class="line">            <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Unsafe:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<p>运用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T02_TestUnsafe t = <span class="keyword">new</span> T02_TestUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class="line"></span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Field f = T02_TestUnsafe.class.getDeclaredField("i");</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        System.out.println(offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> success = unsafe.compareAndSwapInt(t, offset, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">        System.out.println(t.i);</span><br><span class="line">        <span class="comment">//unsafe.compareAndSwapInt()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: unsafe.cpp:</p>
<p>cmpxchg = compare and exchange</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp <strong>93行</strong></p>
<p>is_MP = Multi Processor  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: os.hpp is_MP()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_MP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// During bootstrap if _processor_count is not yet initialized</span></span><br><span class="line">  <span class="comment">// we claim to be MP as that is safest. If any platform has a</span></span><br><span class="line">  <span class="comment">// stub generator that might be triggered in this phase and for</span></span><br><span class="line">  <span class="comment">// which being declared MP when in fact not, is a problem - then</span></span><br><span class="line">  <span class="comment">// the bootstrap routine for the stub generator needs to check</span></span><br><span class="line">  <span class="comment">// the processor count directly and leave the bootstrap routine</span></span><br><span class="line">  <span class="comment">// in place until called after initialization has ocurred.</span></span><br><span class="line">  <span class="keyword">return</span> (_processor_count != <span class="number">1</span>) || AssumeMP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jdk8u: atomic_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure>

<p>最终实现：</p>
<p>cmpxchg = cas修改变量值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock cmpxchg 指令</span><br></pre></td></tr></table></figure>

<p>硬件：</p>
<p>lock指令在执行后面指令的时候锁定一个北桥信号</p>
<p>（不采用锁总线的方式）</p>
<h1 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h1><h1 id="工具：JOL-Java-Object-Layout"><a href="#工具：JOL-Java-Object-Layout" class="headerlink" title="工具：JOL = Java Object Layout"></a>工具：JOL = Java Object Layout</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>jdk8u: markOop.hpp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span><br><span class="line"><span class="comment">//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span><br><span class="line"><span class="comment">//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span><br></pre></td></tr></table></figure>





<h1 id="synchronized的横切面详解"><a href="#synchronized的横切面详解" class="headerlink" title="synchronized的横切面详解"></a>synchronized的横切面详解</h1><ol>
<li>synchronized原理</li>
<li>升级过程</li>
<li>汇编实现</li>
<li>vs reentrantLock的区别</li>
</ol>
<h2 id="java源码层级"><a href="#java源码层级" class="headerlink" title="java源码层级"></a>java源码层级</h2><p>synchronized(o) </p>
<h2 id="字节码层级"><a href="#字节码层级" class="headerlink" title="字节码层级"></a>字节码层级</h2><p>monitorenter moniterexit</p>
<h2 id="JVM层级（Hotspot）"><a href="#JVM层级（Hotspot）" class="headerlink" title="JVM层级（Hotspot）"></a>JVM层级（Hotspot）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.insidesync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_Sync1</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mashibing.insidesync.T01_Sync1$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000101</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">5</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes total</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.mashibing.insidesync.T02_Sync2$Lock object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>   (object header)  <span class="number">05</span> <span class="number">90</span> <span class="number">2</span>e <span class="number">1</span>e (<span class="number">00000101</span> <span class="number">10010000</span> <span class="number">00101110</span> <span class="number">00011110</span>) (<span class="number">506368005</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>   (object header)  <span class="number">1</span>b <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00011011</span> <span class="number">00000010</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">539</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>   (object header)  <span class="number">49</span> ce <span class="number">00</span> <span class="number">20</span> (<span class="number">01001001</span> <span class="number">11001110</span> <span class="number">00000000</span> <span class="number">00100000</span>) (<span class="number">536923721</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>        (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">16</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">4</span> bytes external = <span class="number">4</span> bytes tota</span><br></pre></td></tr></table></figure>

<p>InterpreterRuntime:: monitorenter方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">"must be NULL or an object"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<p>synchronizer.cpp</p>
<p>revoke_and_rebias</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">"can not rebias toward VM thread"</span>);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">"biases should be revoked by now"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">"should not see bias pattern here"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: <span class="built_in">release</span> stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">"must not re-lock the same lock"</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">"don't relock with same BasicLock"</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn't particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_monitor() &amp;&amp; mark-&gt;monitor()-&gt;is_entered(THREAD)) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inflate方法：膨胀为重量级锁</p>
<h1 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h1><h2 id="JDK8-markword实现表："><a href="#JDK8-markword实现表：" class="headerlink" title="JDK8 markword实现表："></a>JDK8 markword实现表：</h2><p><img src="./markword.png" alt="markword"></p>
<p>new - 偏向锁 - 轻量级锁 （无锁, 自旋锁，自适应自旋）- 重量级锁</p>
<p>synchronized优化的过程和markword息息相关</p>
<p>用markword中最低的三位代表锁状态 其中1位是偏向锁位 两位是普通锁位</p>
<ol>
<li><p>Object o = new Object()<br>锁 = 0 01 无锁态<br>注意：如果偏向锁打开，默认是匿名偏向状态</p>
</li>
<li><p>o.hashCode()<br>001 + hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000001</span> <span class="number">10101101</span> <span class="number">00110100</span> <span class="number">00110110</span></span><br><span class="line"><span class="number">01011001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>little endian big endian </p>
<p>00000000 00000000 00000000 01011001 00110110 00110100 10101101 00000000</p>
</li>
<li><p>默认synchronized(o)<br>00 -&gt; 轻量级锁<br>默认情况 偏向锁有个时延，默认是4秒<br>why? 因为JVM虚拟机自己有一些默认启动的线程，里面有好多sync代码，这些sync代码启动时就知道肯定会有竞争，如果使用偏向锁，就会造成偏向锁不断的进行锁撤销和锁升级的操作，效率较低。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:BiasedLockingStartupDelay=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果设定上述参数<br>new Object () - &gt; 101 偏向锁 -&gt;线程ID为0 -&gt; Anonymous BiasedLock<br>打开偏向锁，new出来的对象，默认就是一个可偏向匿名对象101</p>
</li>
<li><p>如果有线程上锁<br>上偏向锁，指的就是，把markword的线程ID改为自己线程ID的过程<br>偏向锁不可重偏向 批量偏向 批量撤销</p>
</li>
<li><p>如果有线程竞争<br>撤销偏向锁，升级轻量级锁<br>线程在自己的线程栈生成LockRecord ，用CAS操作将markword设置为指向自己这个线程的LR的指针，设置成功者得到锁</p>
</li>
<li><p>如果竞争加剧<br>竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin， 或者自旋线程数超过CPU核数的一半， 1.6之后，加入自适应自旋 Adapative Self Spinning ， JVM自己控制<br>升级重量级锁：-&gt; 向操作系统申请资源，linux mutex , CPU从3级-0级系统调用，线程挂起，进入等待队列，等待操作系统的调度，然后再映射回用户空间</p>
</li>
</ol>
<p>(以上实验环境是JDK11，打开就是偏向锁，而JDK8默认对象头是无锁)</p>
<p>偏向锁默认是打开的，但是有一个时延，如果要观察到偏向锁，应该设定参数</p>
<p><strong>如果计算过对象的hashCode，则对象无法进入偏向状态！</strong></p>
<blockquote>
<p>轻量级锁重量级锁的hashCode存在与什么地方？</p>
<p>答案：线程栈中，轻量级锁的LR中，或是代表重量级锁的ObjectMonitor的成员中</p>
</blockquote>
<p>关于epoch: (不重要)</p>
<blockquote>
<p><strong>批量重偏向与批量撤销</strong>渊源：从偏向锁的加锁解锁过程中可看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时，再将偏向锁撤销为无锁状态或升级为轻量级，会消耗一定的性能，所以在多线程竞争频繁的情况下，偏向锁不仅不能提高性能，还会导致性能下降。于是，就有了批量重偏向与批量撤销的机制。</p>
<p><strong>原理</strong>以class为单位，为每个class维护<strong>解决场景</strong>批量重偏向（bulk rebias）机制是为了解决：一个线程创建了大量对象并执行了初始的同步操作，后来另一个线程也来将这些对象作为锁对象进行操作，这样会导致大量的偏向锁撤销操作。批量撤销（bulk revoke）机制是为了解决：在明显多线程竞争剧烈的场景下使用偏向锁是不合适的。</p>
<p>一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的Mark Word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其Mark Word的Thread Id 改成当前线程Id。当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
</blockquote>
<p>没错，我就是厕所所长</p>
<p>加锁，指的是锁定对象</p>
<p>锁升级的过程</p>
<p>JDK较早的版本 OS的资源 互斥量 用户态 -&gt; 内核态的转换 重量级 效率比较低</p>
<p>现代版本进行了优化</p>
<p>无锁 - 偏向锁 -轻量级锁（自旋锁）-重量级锁</p>
<p>偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁</p>
<p>有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁</p>
<p>自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin</p>
<p>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<p>偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</p>
<h2 id="synchronized最底层实现"><a href="#synchronized最底层实现" class="headerlink" title="synchronized最底层实现"></a>synchronized最底层实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123; i++; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publics <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">1000_000</span>; j++) &#123;</span><br><span class="line">            m();</span><br><span class="line">            n();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly T</p>
<p>C1 Compile Level 1 (一级优化)</p>
<p>C2 Compile Level 2 (二级优化)</p>
<p>找到m() n()方法的汇编码，会看到 lock comxchg …..指令</p>
<h2 id="synchronized-vs-Lock-CAS"><a href="#synchronized-vs-Lock-CAS" class="headerlink" title="synchronized vs Lock (CAS)"></a>synchronized vs Lock (CAS)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在高争用 高耗时的环境下synchronized效率更高</span><br><span class="line">在低争用 低耗时的环境下CAS效率更高</span><br><span class="line">synchronized到重量级之后是等待队列（不消耗CPU）</span><br><span class="line">CAS（等待期间消耗CPU）</span><br><span class="line"></span><br><span class="line">一切以实测为准</span><br></pre></td></tr></table></figure>



<h1 id="锁消除-lock-eliminate"><a href="#锁消除-lock-eliminate" class="headerlink" title="锁消除 lock eliminate"></a>锁消除 lock eliminate</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">         StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">         sb.append(str1).append(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。</p>
<h1 id="锁粗化-lock-coarsening"><a href="#锁粗化-lock-coarsening" class="headerlink" title="锁粗化 lock coarsening"></a>锁粗化 lock coarsening</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       StringBuffer sb = <span class="keyword">new</span> StringBuffer():</span><br><span class="line">       <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">           sb.append(str);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。</p>
<h1 id="锁降级（不重要）"><a href="#锁降级（不重要）" class="headerlink" title="锁降级（不重要）"></a>锁降级（不重要）</h1><p><a href="https://www.zhihu.com/question/63859501" target="_blank" rel="noopener">https://www.zhihu.com/question/63859501</a></p>
<p>其实，只被VMThread访问，降级也就没啥意义了。所以可以简单认为锁降级不存在！</p>
<h1 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h1><p>一个ALU + 两组Registers + PC</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p>
<h1 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h1><h2 id="1-线程可见性"><a href="#1-线程可见性" class="headerlink" title="1.线程可见性"></a>1.线程可见性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.testvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T01_ThreadVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//do sth</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;, <span class="string">"server"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-防止指令重排序"><a href="#2-防止指令重排序" class="headerlink" title="2.防止指令重排序"></a>2.防止指令重排序</h2><h3 id="问题：DCL单例需不需要加volatile？"><a href="#问题：DCL单例需不需要加volatile？" class="headerlink" title="问题：DCL单例需不需要加volatile？"></a>问题：DCL单例需不需要加volatile？</h3><h3 id="CPU的基础知识"><a href="#CPU的基础知识" class="headerlink" title="CPU的基础知识"></a>CPU的基础知识</h3><ul>
<li><p>缓存行对齐<br>缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高<br>Disruptor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_028_FalseSharing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_CacheLinePadding</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7; <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">Padding</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] arr = <span class="keyword">new</span> T[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> T();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">0</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="number">1000_0000L</span>; i++) &#123;</span><br><span class="line">                arr[<span class="number">1</span>].x = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println((System.nanoTime() - start)/<span class="number">100_0000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MESI</p>
</li>
<li><p>伪共享</p>
</li>
<li><p>合并写<br>CPU内部的4个字节的Buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.juc.c_029_WriteCombining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteCombining</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITERATIONS = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ITEMS = <span class="number">1</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MASK = ITEMS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayB = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayD = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayE = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] arrayF = <span class="keyword">new</span> <span class="keyword">byte</span>[ITEMS];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">" SingleLoop duration (ns) = "</span> + runCaseOne());</span><br><span class="line">            System.out.println(i + <span class="string">" SplitLoop  duration (ns) = "</span> + runCaseTwo());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">runCaseTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">int</span> i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayA[slot] = b;</span><br><span class="line">            arrayB[slot] = b;</span><br><span class="line">            arrayC[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        i = ITERATIONS;</span><br><span class="line">        <span class="keyword">while</span> (--i != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> slot = i &amp; MASK;</span><br><span class="line">            <span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i;</span><br><span class="line">            arrayD[slot] = b;</span><br><span class="line">            arrayE[slot] = b;</span><br><span class="line">            arrayF[slot] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>指令重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.c3_jmm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T04_Disorder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span></span><br><span class="line">                    <span class="comment">//shortWait(100000);</span></span><br><span class="line">                    a = <span class="number">1</span>;</span><br><span class="line">                    x = b;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    b = <span class="number">1</span>;</span><br><span class="line">                    y = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start();other.start();</span><br><span class="line">            one.join();other.join();</span><br><span class="line">            String result = <span class="string">"第"</span> + i + <span class="string">"次 ("</span> + x + <span class="string">","</span> + y + <span class="string">"）"</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                System.err.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//System.out.println(result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortWait</span><span class="params">(<span class="keyword">long</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            end = System.nanoTime();</span><br><span class="line">        &#125;<span class="keyword">while</span>(start + interval &gt;= end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="系统底层如何实现数据一致性"><a href="#系统底层如何实现数据一致性" class="headerlink" title="系统底层如何实现数据一致性"></a>系统底层如何实现数据一致性</h3><ol>
<li>MESI如果能解决，就使用MESI</li>
<li>如果不能，就锁总线</li>
</ol>
<h3 id="系统底层如何保证有序性"><a href="#系统底层如何保证有序性" class="headerlink" title="系统底层如何保证有序性"></a>系统底层如何保证有序性</h3><ol>
<li>内存屏障sfence mfence lfence等系统原语</li>
<li>锁总线</li>
</ol>
<h3 id="volatile如何解决指令重排序"><a href="#volatile如何解决指令重排序" class="headerlink" title="volatile如何解决指令重排序"></a>volatile如何解决指令重排序</h3><p>1: volatile i</p>
<p>2: ACC_VOLATILE</p>
<p>3: JVM的内存屏障</p>
<p>​    屏障两边的指令不可以重排！保障有序！</p>
<p>4：hotspot实现</p>
<p>bytecodeinterpreter.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> field_offset = cache-&gt;f2_as_index();</span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::fence();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>orderaccess_linux_x86.inline.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (os::is_MP()) &#123;</span><br><span class="line">    <span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%rsp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">"lock; addl $0,0(%%esp)"</span> : : : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用hsdis观察synchronized和volatile"><a href="#用hsdis观察synchronized和volatile" class="headerlink" title="用hsdis观察synchronized和volatile"></a>用hsdis观察synchronized和volatile</h1><ol>
<li><p>安装hsdis (自行百度)</p>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;</span><br><span class="line">       m();</span><br><span class="line">       n();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="css"><span class="selector-tag">java</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+UnlockDiagnosticVMOptions</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+PrintAssembly</span> <span class="selector-tag">T</span> &gt; 1<span class="selector-class">.txt</span>
&lt;!<span class="selector-tag">--</span>￼30<span class="selector-tag">--</span>&gt;
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
</search>
