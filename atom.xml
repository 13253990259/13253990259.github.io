<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冠星的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gxblog.club/"/>
  <updated>2020-06-25T07:05:26.013Z</updated>
  <id>http://gxblog.club/</id>
  
  <author>
    <name>Liu_gx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis插件原理</title>
    <link href="http://gxblog.club/2020/06/25/4.MyBatis%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://gxblog.club/2020/06/25/4.MyBatis%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-25T09:04:00.000Z</published>
    <updated>2020-06-25T07:05:26.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis插件原理"><a href="#MyBatis插件原理" class="headerlink" title="MyBatis插件原理"></a>MyBatis插件原理</h1><h3 id="MyBatis插件原理与自定义插件"><a href="#MyBatis插件原理与自定义插件" class="headerlink" title="MyBatis插件原理与自定义插件"></a>MyBatis插件原理与自定义插件</h3><h5 id="1-插件的使用"><a href="#1-插件的使用" class="headerlink" title="1.插件的使用"></a>1.插件的使用</h5><p>运行自定义的插件，需要3步，我们以PageHelper为例：</p><p>插件编写,编写拦截器类，需要做的有三点</p><p>①.实现Interceptor接口</p><p>②.实现相应的方法。最关键的是intercept(）方法里面是拦截的逻辑， 需要增强的功能代码就写在这里。</p><p>③.在拦截器类加上注解@Intercepts。注解签名指定了需要拦截的对象、拦截的方法、参数（因为方法有不同的重载， 所以要指定具体的参数）。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>, args = &#123; MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">RowBounds</span>.<span class="title">class</span>, <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最关键的是intercept方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//plugin获取代理对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置配置&lt;plugins&gt;中标签的属性设置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-插件配置"><a href="#2-插件配置" class="headerlink" title="2.插件配置"></a>2.插件配置</h5><p>在mybatis-config.xml中注册插件，配置属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.gxedu.interceptor.TableInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"offsetAsPageNum"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rowBoundsWithCount"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pageSizeZero"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"reasonable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"params"</span> <span class="attr">value</span>=<span class="string">"pageNum=start;pageSize=limit; "</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportMethodsArguments"</span> <span class="attr">value</span>= <span class="string">"true"</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"retumPagelnfo"</span> <span class="attr">value</span>=<span class="string">"check"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>插件解析注册</p><p>MyBatis启 动时扫描<plugins>标签， 注册到Configuration对象的lnterceptorChain中。property里面的参数，会调用setProperties(）方法处理。</p><p>在启动解析的时候，把所有的插件全部存到了Configuration的lnterceptorChain中，它是一个List。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLConfigBuilder</span> <span class="keyword">extends</span> <span class="title">BaseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">      Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      loadCustomLogImpl(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      <span class="comment">//完成第一步插件的配置的解析工作</span></span><br><span class="line">      pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//解析插件,获取每一个&lt;interceptor&gt;标签变成一个Interceptor拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">        Properties properties = child.getChildrenAsProperties();</span><br><span class="line">        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        <span class="comment">//添加到configuration中</span></span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拦截器链,存放我们定义的拦截器</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptorChain.addInterceptor(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//调用addInterceptor()方法,添加到List&lt;Interceptor&gt; interceptors中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h6><p>MyBatis的插件不用修改原jar包的代码，就可以改变核心对象的行为，比如在前面处理参数，在中间处理 SQL, 在最后处理结果集。</p><ul><li><p>不修改代码怎么增强功能？</p><p>不修改对象的代码， 怎么对对象的行为进行修改，比如说在原来的方法前面做一点事情， 在原来的方法后面做一点事情？</p><p>很容易能想到用代理模式， 这个也确实是 M-yBatis 插件的实现原理。</p></li><li><p>多个插件怎么拦截？</p><p>我们可以定义很多的插件， 那么这种所有的插件会形成一个链路，执行完了第一个插件的逻辑， 要继续执行第二个第三个插件的逻辑。</p><p>比如我们提交一个休假申请， 先是项目经理审批， 然后是部门经理审批， 再是 HR审批， 再到总经理审批， 怎么实现层层的拦截？如果是代理模式， 已经被代理过的对象，可以再次被代理吗？</p><p>答案：插件是层层拦截的， 我们又需要用到另一种设计模式——责任链模式。</p></li><li><p>什么对象可以被拦截？</p><p>如果是用代理模式， 我们就要解决几个问题：</p><p>1 、有哪些对象允许被代理？有哪些方法可以被拦截？</p><p>并不是每一个运行的节点都是可以被修改的（如果没有这种规范， 就会造成混乱和带来风险）。 只有清楚了这些对象的方法的作用， 当我们自己编写插件的时候才知道从哪里去拦截。</p><p><img src="https://i.loli.net/2020/05/16/nuWjF74P19ZmV56.png" alt="image.png"></p><p>这里需要注意的是， 因为 Executor 有可能被二级缓存装饰， 那么是先代理再装饰，还是先装饰后代理呢？</p><p>Executor 会拦截到 CachingExcecutor 或者 BaseExecutor。</p><p>DefaultSqlSessionFactory.openSessionFromDataSource() </p><p>先创建基本类型SimpleExecutor， 再二级缓存装饰CachingExecutor， 最后插件拦截interceptorChain.pluginAll(executor)。 所以这里拦截的是Caching Executor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/*ExecutorType.BATCH</span></span><br><span class="line"><span class="comment">    配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）；</span></span><br><span class="line"><span class="comment">    BATCH 执行器不仅重用语句还会执行批量更新。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(); <span class="comment">//  ExecutorType.BATCH</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String str = <span class="string">"2020-02-26"</span>;</span><br><span class="line">        SimpleDateFormat sm = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Fee fee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fee = <span class="keyword">new</span> Fee (sm.parse (str));</span><br><span class="line">            FeeMapper mapper = session.getMapper(FeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;Fee&gt; list = mapper.selectByFeeDate(fee);</span><br><span class="line">            session.commit ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSqlSessionFactory</span> <span class="keyword">implements</span> <span class="title">SqlSessionFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">        Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">          <span class="comment">// 获取事务工厂</span></span><br><span class="line">          <span class="keyword">final</span> TransactionFactory transactionFactory =                         getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">          <span class="comment">// 创建事务</span></span><br><span class="line">          tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">          <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">          <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">          <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">        Executor executor;</span><br><span class="line">        <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">          executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">          executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">        <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">            <span class="comment">//如果开启缓冲对,二级缓冲的包装成CachingExecutor</span></span><br><span class="line">          executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">        executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-插件实现原理"><a href="#3-插件实现原理" class="headerlink" title="3.插件实现原理"></a>3.插件实现原理</h5><p>如果是代理模式， 又有几个问题需要解决：</p><p>1 、 代理类怎么创建？动态代理是 JDK Proxy 还是 Cglib？怎么样创建代理？</p><p>2、 代理类在什么时候创建？是在解析配置的时候创建， 还是获取会话的时候创建，还是在调用的时候创建？</p><p>3、 核心对象被代理之后， 调用的流程是怎么样的？怎么依次执行多个插件的逻辑？在执行完了插件的逻辑之后， 怎么执行原来的逻辑？</p><p>只要理解了代理模式在这里的运用， 就理解了插件的工作流程。</p><p>代理类什么时候创建？</p><p>对Executor拦截的代理类是openSession(）的时候创建的。</p><p>Configuration.newExecutor() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//调用openSessionFromDataSource()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 创建事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 根据事务工厂和默认的执行器类型，创建执行器 &gt;&gt;</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//调用configuration.newExecutor(tx, execType)创建执行器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认 SimpleExecutor</span></span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二级缓存开关，settings 中的 cacheEnabled 默认是 true</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 植入插件的逻辑，至此，四大对象已经全部拦截完毕</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>StatementHandler是SimpleExecutor.doQuery(）创建的；里面包含了ParameterHandler和ResultSetHandler的创建和代理。以及如果使用插件进行拦截.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 注意，已经来到SQL处理的关键对象 StatementHandler &gt;&gt;</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="comment">// 获取一个 Statement对象</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="comment">// 执行查询</span></span><br><span class="line">      <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 用完就关闭</span></span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// StatementType 是怎么来的？ 增删改查标签中的 statementType="PREPARED"，默认值 PREPARED</span></span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="comment">//Statement 每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.</span></span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        <span class="comment">// 创建 StatementHandler 的时候做了什么？ &gt;&gt;</span></span><br><span class="line">        <span class="comment">//PreparedStatement是预编译的</span></span><br><span class="line">        <span class="comment">//a. 在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。</span></span><br><span class="line">        <span class="comment">// b. 安全性好，有效防止Sql注入等问题。</span></span><br><span class="line">        <span class="comment">// c.  对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；</span></span><br><span class="line">        <span class="comment">// d.  代码的可读性和可维护性。</span></span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//CallableStatement接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。</span></span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Unknown statement type: "</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PreparedStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = mappedStatement.getConfiguration();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.mappedStatement = mappedStatement;</span><br><span class="line">    <span class="keyword">this</span>.rowBounds = rowBounds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.typeHandlerRegistry = configuration.getTypeHandlerRegistry();</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = configuration.getObjectFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boundSql == <span class="keyword">null</span>) &#123; <span class="comment">// issue #435, get the key before calculating the statement</span></span><br><span class="line">      generateKeys(parameterObject);</span><br><span class="line">      boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建了四大对象的其它两大对象 &gt;&gt;</span></span><br><span class="line">    <span class="comment">// 创建这两大对象的时候分别做了什么？</span></span><br><span class="line">    <span class="comment">//ParameterHandler参数处理</span></span><br><span class="line">    <span class="keyword">this</span>.parameterHandler = configuration.newParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">//ResultSetHandler结果集处理</span></span><br><span class="line">    <span class="keyword">this</span>.resultSetHandler = configuration.newResultSetHandler(executor, mappedStatement, rowBounds, parameterHandler, resultHandler, boundSql);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    <span class="comment">// 植入插件逻辑（返回代理对象）</span></span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代理怎么创建？</p><p>调用lnterceptorChain的pluginAII(）方法，做了什么事？</p><p>遍历lnterceptorChain，使用Interceptor实现类的plugin(）方法，对目标核心对象进行代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//遍历拦截器链,代理+包装创建代理对象</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">        <span class="comment">//调用interceptor.plugin()创建代理对象</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 plugin 方法是我们自己实现的， 要返回一个代理对象。</p><p>如果是JDK动态代理，那我们必须要写 一个实现了lnvocationHandler接口的触发管理类。 然后用 Proxy.newProxylnstance(）创建一个代理对象。</p><p>Mybatis 的插件机制已经把这些类封装好了，它已经提供了一个触发管理类 Plugin, 实现了 lnvocationHandler。</p><p>创建代理对象的newProxylnstance(）在这个类里面也进行了封装，就是wrap(）方法。</p><p>在 wrap 的时候创建了一个 Plugin 对象， Plugin 是被代理对象、 Interceptor 的一个封装对象：</p><p>new Plugin(target, interceptor, signatureMap)</p><p>持有了被代理对象和interceptor的实例：</p><p>因为这里是 for 循环代理，所以某个核心对象有多个插件，会返回被代理多次的代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义插件,在调用interceptor.plugin(target)方法,会调用自定义插件的plugin()方法</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor<span class="class">.<span class="keyword">class</span>, <span class="title">method</span> </span>= <span class="string">"query"</span>, args = &#123; MappedStatement<span class="class">.<span class="keyword">class</span>, <span class="title">Object</span>.<span class="title">class</span>, <span class="title">RowBounds</span>.<span class="title">class</span>, <span class="title">ResultHandler</span>.<span class="title">class</span>&#125;) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TableInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Plugin.warp()创建代理对象,因为我们的Plugin对象默认实现了InvocationHandler接口</span></span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Proxy.newProxyInstance()的jdk动态代理创建代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了InvocationHandler的默认需要重写invoke()方法,会先执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//被代理的目标对象</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//执行的拦截器</span></span><br><span class="line">        <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">        <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>被代理之后， 调用的流程？</p><p>在四大核心对象的一次执行过程中（可能被代理多次）， 因为已经被代理了， 所以会先走到触发管理类Plugin的invoke(）方法。</p><p>如果被拦截的方法不为空，进入Plugin的invoke(）方法，调用interceptor的intercept(）方法：</p><p>到了 intercept(）方法，也就走到了我们自己实现的拦截逻辑（例如 Pagelnterceptor 的intercept(）方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">          <span class="comment">//调用interceptor的intercept(）方法实现自定义拦截</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意参数是new出来的Invocation对象(new Invocation(target, method, args))，它是对被拦截对象、被拦截方法、被拦截参数的一个封装。 为什么要传这样一个参数呢？</p><p>当然， 在代理逻辑执行完了之后， 比如继续执行被代理对象（四大核心对象）的原方法， 也就是说要有一行这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br></pre></td></tr></table></figure><p>或者拿到被代理的核心对象， 继续执行它的方法（比如 executor.query()) 。这个时候， 我们要拿到被代理对象和它的参数， 去哪里拿？</p><p>就是上面创建的 Invocation 对象。 它简化了参数的传递， 而且直接提供了一个proceed(）方法， 也就是说继续执行原方法可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Invocation</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object[] getArgs() &#123;</span><br><span class="line">    <span class="keyword">return</span> args;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">//直接调用proceed()方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/16/WMEpLf4c5kJnZNw.png" alt="image.png"></p><p>如果说对象被代理了多次， 这里会继续调用下一个插件的逻辑， 再走一次 Plugin 的invoke(）方法。 这里我们需要关注一下有多个插件的时候的运行顺序。</p><ul><li>配置的顺序和执行的顺序？</li></ul><p>配置的顺序和执行的顺序是相反的。lnterceptorChain的List是按照插件从上往下的顺序解析、 添加的。</p><p>而创建代理的时候也是按照Iist的顺序代理。执行的时候当然是从最后代理的对象开始。</p><p><img src="https://i.loli.net/2020/05/16/gpdBkWHyZqmAnFV.png" alt="image.png"></p><h5 id="4、PageHelper原理"><a href="#4、PageHelper原理" class="headerlink" title="4、PageHelper原理"></a>4、PageHelper原理</h5><ul><li><p>逻辑翻页</p><p>使用RowBounds翻页 ， 在内存中筛选数据。</p><p>使用和参数传递</p><p>在引入了 pageHelper 的依赖， 配置了插件之后， 如果我们需要翻页， 需要用到相关的工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pn, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>在 PageHelper 类中指定页码和每页数量。 MyBatis 的方法不用做任何的修改， 最后可以把结果包装成一个 Pagelnfo 返回给前端。</p><p>如果不需要翻页， 把这两行代码去掉就行了。 插件的优点就是不用修改 MyBatis 本身的代码。</p></li><li><p>SQL改写的实现</p><p>PageHelper到底是怎么通过拦截实现翻页的呢？</p><p>首先看一下拦截器，Pagelnterceptor类。</p><p>首先判断是否需要 count 获取总数，默认是 true。获得 count 之后， 判断是否需要分页， 如果 pageSize&gt;O, 就分页。</p><p>这里通过 getPageSql()方法生成了一个新的 BoundSql:</p><p>getPageSql()对于不同的数据库有不同的实现：</p><p><img src="https://i.loli.net/2020/05/17/MUOENaqnjs6olIK.png" alt="image.png"></p><p>以MySQL为例， 实际上是添加了LIMIT语句， 加上了起始位置和结束位置：</p><p>问题是， 插件是怎么获取到页码和每页数量， 是怎么传递给插件的？</p><p>回头看看PageHelper.startPage(）方法， startPage(）调用了PageMethod的setlocalPage(）方法， 包装了一个Page对象， 并且把这个对象放到了ThreadLocal变量中。</p><p>而在AbstractHelperDialect中 ， Page对象中的翻页信息是通过getlocalPage()取出来的：</p><p>它调用的正是PageHelper的getlocalPage(）, 从ThreadLocal中获取到了翻页信息</p><p>所以， 每次查询（每 —个线程）都会有 —个线程私有的Page对象 ， 它里面有页码和每页数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Page&lt;E&gt; <span class="title">startPage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize, <span class="keyword">boolean</span> count)</span> </span>&#123;</span><br><span class="line">        Page&lt;E&gt; page = <span class="keyword">new</span> Page(pageNum, pageSize, count);</span><br><span class="line">        setLocalPage(page);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelperDialect</span> <span class="keyword">extends</span> <span class="title">AbstractDialect</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        <span class="comment">//从ThreadLocal中获取分页的设置的起始页,以及每页显示的条数</span></span><br><span class="line">        Page page = <span class="keyword">this</span>.getLocalPage();</span><br><span class="line">        <span class="comment">//getPageSql()获取不同数据库厂商的分页关键字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPageSql(sql, page, pageKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ThreadLoacl中获取分页参数</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PageHelper.getLocalPage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Page&lt;T&gt; <span class="title">getLocalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Page)LOCAL_PAGE.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/17/91EYKjsvUxzy4Xa.png" alt="image.png"></p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Cache&lt;CacheKey, MappedStatement&gt; msCountMap = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Dialect dialect;</span><br><span class="line">    <span class="keyword">private</span> String default_dialect_class = <span class="string">"com.github.pagehelper.PageHelper"</span>;</span><br><span class="line">    <span class="keyword">private</span> Field additionalParametersField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object var22;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args = invocation.getArgs();</span><br><span class="line">            MappedStatement ms = (MappedStatement)args[<span class="number">0</span>];</span><br><span class="line">            Object parameter = args[<span class="number">1</span>];</span><br><span class="line">            RowBounds rowBounds = (RowBounds)args[<span class="number">2</span>];</span><br><span class="line">            ResultHandler resultHandler = (ResultHandler)args[<span class="number">3</span>];</span><br><span class="line">            Executor executor = (Executor)invocation.getTarget();</span><br><span class="line">            CacheKey cacheKey;</span><br><span class="line">            <span class="comment">//原生的sql语句</span></span><br><span class="line">            BoundSql boundSql;</span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">4</span>) &#123;</span><br><span class="line">                boundSql = ms.getBoundSql(parameter);</span><br><span class="line">                cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cacheKey = (CacheKey)args[<span class="number">4</span>];</span><br><span class="line">                boundSql = (BoundSql)args[<span class="number">5</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List resultList;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dialect.skip(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; additionalParameters = (Map)<span class="keyword">this</span>.additionalParametersField.get(boundSql);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.dialect.beforeCount(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    CacheKey countKey = executor.createCacheKey(ms, parameter, RowBounds.DEFAULT, boundSql);</span><br><span class="line">                    countKey.update(<span class="string">"_Count"</span>);</span><br><span class="line">                    MappedStatement countMs = (MappedStatement)<span class="keyword">this</span>.msCountMap.get(countKey);</span><br><span class="line">                    <span class="keyword">if</span> (countMs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        countMs = MSUtils.newCountMappedStatement(ms);</span><br><span class="line">                        <span class="keyword">this</span>.msCountMap.put(countKey, countMs);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String countSql = <span class="keyword">this</span>.dialect.getCountSql(ms, boundSql, parameter, rowBounds, countKey);</span><br><span class="line">                    BoundSql countBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(), parameter);</span><br><span class="line">                    Iterator var16 = additionalParameters.keySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var16.hasNext()) &#123;</span><br><span class="line">                        String key = (String)var16.next();</span><br><span class="line">                        countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object countResultList = executor.query(countMs, parameter, RowBounds.DEFAULT, resultHandler, countKey, countBoundSql);</span><br><span class="line">                    Long count = (Long)((List)countResultList).get(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.dialect.afterCount(count, parameter, rowBounds)) &#123;</span><br><span class="line">                        Object var18 = <span class="keyword">this</span>.dialect.afterPage(<span class="keyword">new</span> ArrayList(), parameter, rowBounds);</span><br><span class="line">                        <span class="keyword">return</span> var18;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.dialect.beforePage(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                    resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, boundSql);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parameter = <span class="keyword">this</span>.dialect.processParameterObject(ms, parameter, boundSql, cacheKey);</span><br><span class="line">                    <span class="comment">//重新生成新的带分页参数的sql语句</span></span><br><span class="line">                    String pageSql = <span class="keyword">this</span>.dialect.getPageSql(ms, boundSql, parameter, rowBounds, cacheKey);</span><br><span class="line">                    BoundSql pageBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), pageSql, boundSql.getParameterMappings(), parameter);</span><br><span class="line">                    Iterator var25 = additionalParameters.keySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!var25.hasNext()) &#123;</span><br><span class="line">                            resultList = executor.query(ms, parameter, RowBounds.DEFAULT, resultHandler, cacheKey, pageBoundSql);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String key = (String)var25.next();</span><br><span class="line">                        pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var22 = <span class="keyword">this</span>.dialect.afterPage(resultList, parameter, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.dialect.afterAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var22;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHelperDialect</span> <span class="keyword">extends</span> <span class="title">AbstractDialect</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, Object parameterObject, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        String sql = boundSql.getSql();</span><br><span class="line">        <span class="comment">//从ThreadLocal中获取分页的设置的起始页,以及每页显示的条数</span></span><br><span class="line">        Page page = <span class="keyword">this</span>.getLocalPage();</span><br><span class="line">        <span class="comment">//getPageSql()获取不同数据库厂商的分页关键字</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getPageSql(sql, page, pageKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//Mysqy的数据库厂商</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlDialect</span> <span class="keyword">extends</span> <span class="title">AbstractHelperDialect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySqlDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPageSql</span><span class="params">(String sql, Page page, CacheKey pageKey)</span> </span>&#123;</span><br><span class="line">        StringBuilder sqlBuilder = <span class="keyword">new</span> StringBuilder(sql.length() + <span class="number">14</span>);</span><br><span class="line">        sqlBuilder.append(sql);</span><br><span class="line">        <span class="keyword">if</span> (page.getStartRow() == <span class="number">0</span>) &#123;</span><br><span class="line">            sqlBuilder.append(<span class="string">" LIMIT "</span>);</span><br><span class="line">            sqlBuilder.append(page.getPageSize());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sqlBuilder.append(<span class="string">" LIMIT "</span>);</span><br><span class="line">            sqlBuilder.append(page.getStartRow());</span><br><span class="line">            sqlBuilder.append(<span class="string">","</span>);</span><br><span class="line">            sqlBuilder.append(page.getPageSize());</span><br><span class="line">            pageKey.update(page.getStartRow());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pageKey.update(page.getPageSize());</span><br><span class="line">        <span class="keyword">return</span> sqlBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      MyBatis插件原理
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://gxblog.club/categories/MyBatis/"/>
    
    
      <category term="插件原理，拦截器" scheme="http://gxblog.club/tags/%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86%EF%BC%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>6.手写MyBatis</title>
    <link href="http://gxblog.club/2020/06/25/6.%E6%89%8B%E5%86%99MyBatis/"/>
    <id>http://gxblog.club/2020/06/25/6.%E6%89%8B%E5%86%99MyBatis/</id>
    <published>2020-06-25T06:21:42.506Z</published>
    <updated>2020-05-14T00:56:22.601Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MyBatis应用分析与最佳实践</title>
    <link href="http://gxblog.club/2020/04/28/1.MyBatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://gxblog.club/2020/04/28/1.MyBatis%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-04-28T09:04:00.000Z</published>
    <updated>2020-06-26T08:23:53.703Z</updated>
    
    <summary type="html">
    
      MyBatis应用分析与最佳实践
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://gxblog.club/categories/MyBatis/"/>
    
    
      <category term="动态sql" scheme="http://gxblog.club/tags/%E5%8A%A8%E6%80%81sql/"/>
    
      <category term="自定义插件" scheme="http://gxblog.club/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>消息队列之RabbitMQ</title>
    <link href="http://gxblog.club/2020/04/26/day05%20%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ(2%E6%97%B652%E5%88%86)/"/>
    <id>http://gxblog.club/2020/04/26/day05%20%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ(2%E6%97%B652%E5%88%86)/</id>
    <published>2020-04-26T06:54:22.000Z</published>
    <updated>2020-06-26T08:23:53.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="day05-消息中间件RabbitMQ-2时52分"><a href="#day05-消息中间件RabbitMQ-2时52分" class="headerlink" title="day05 消息中间件RabbitMQ (2时52分)"></a>day05 消息中间件RabbitMQ (2时52分)</h1><h2 id="1-页面发布-需求分析-11分28秒"><a href="#1-页面发布-需求分析-11分28秒" class="headerlink" title="1.页面发布-需求分析 (11分28秒)"></a>1.页面发布-需求分析 (11分28秒)</h2><p><a href="https://i.loli.net/2020/05/08/n57CcxgQNul6Per.jpg" target="_blank" rel="noopener">https://i.loli.net/2020/05/08/n57CcxgQNul6Per.jpg</a></p><p><img src="assets/1542500496415.png" alt="1542500496415"></p><a id="more"></a><p>业务流程如下：<br>1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。<br>2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。<br>3、静态化成功后，向消息队列发送页面发布的消息。<br>页面发布的最终目标是将页面发布到服务器。<br>通过消息队列将页面发布的消息发送给各各服务器。<br>3、消息队列负责将消息发送给各各服务器上部署的Cms Client(Cms客户端)。<br>在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。<br>4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并将Html文件存储在本地服务器。<br>CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。</p><h2 id="2-RabbitMQ研究-RabbitMQ介绍-5分26秒"><a href="#2-RabbitMQ研究-RabbitMQ介绍-5分26秒" class="headerlink" title="2.RabbitMQ研究-RabbitMQ介绍 (5分26秒)"></a>2.RabbitMQ研究-RabbitMQ介绍 (5分26秒)</h2><p>MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message<br>Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开<br>发中应用非常广泛。RabbitMQ官方地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p><h3 id="开发中消息队列通常有如下应用场景："><a href="#开发中消息队列通常有如下应用场景：" class="headerlink" title="开发中消息队列通常有如下应用场景："></a>开发中消息队列通常有如下应用场景：</h3><p>1、任务异步处理。<br>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。<br>2、应用程序解耦合<br>MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。</p><h3 id="市场上还有哪些消息队列？"><a href="#市场上还有哪些消息队列？" class="headerlink" title="市场上还有哪些消息队列？"></a>市场上还有哪些消息队列？</h3><p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。</p><h3 id="为什么使用RabbitMQ呢？"><a href="#为什么使用RabbitMQ呢？" class="headerlink" title="为什么使用RabbitMQ呢？"></a>为什么使用RabbitMQ呢？</h3><p>1、使得简单，功能强大。<br>2、基于AMQP协议。<br>3、社区活跃，文档完善。<br>4、高并发性能好，这主要得益于Erlang语言。<br>5、Spring Boot默认已集成RabbitMQ</p><h3 id="AMQP是什么-？"><a href="#AMQP是什么-？" class="headerlink" title="AMQP是什么 ？"></a>AMQP是什么 ？</h3><p><img src="assets/1542500632001.png" alt="1542500632001"></p><p>总结：AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。<br>官方：<a href="http://www.amqp.org/" target="_blank" rel="noopener">http://www.amqp.org/</a></p><h3 id="JMS是什么-？"><a href="#JMS是什么-？" class="headerlink" title="JMS是什么 ？"></a>JMS是什么 ？</h3><p><img src="assets/1542500625579.png" alt="1542500625579"></p><p>总结：<br>JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的<br>jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消<br>息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。</p><h2 id="3-RabbitMQ研究-工作原理-6分28秒"><a href="#3-RabbitMQ研究-工作原理-6分28秒" class="headerlink" title="3.RabbitMQ研究-工作原理 (6分28秒)"></a>3.RabbitMQ研究-工作原理 (6分28秒)</h2><p><img src="assets/1542500760568.png" alt="1542500760568"></p><p>组成部分说明如下：<br>Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。</p><p>Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。</p><p>Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。<br>Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。<br>Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。<br>消息发布接收流程：<br>—–发送消息—–<br>1、生产者和Broker建立TCP连接。<br>2、生产者和Broker建立通道。<br>3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。<br>4、Exchange将消息转发到指定的Queue（队列）<br>—-接收消息—–<br>1、消费者和Broker建立TCP连接<br>2、消费者和Broker建立通道<br>3、消费者监听指定的Queue（队列）<br>4、当有消息到达Queue时Broker默认将消息推送给消费者。<br>5、消费者接收到消息。</p><h2 id="4-RabbitMQ研究-安装RabbitMQ-9分3秒"><a href="#4-RabbitMQ研究-安装RabbitMQ-9分3秒" class="headerlink" title="4.RabbitMQ研究-安装RabbitMQ (9分3秒)"></a>4.RabbitMQ研究-安装RabbitMQ (9分3秒)</h2><h3 id="安装erlang"><a href="#安装erlang" class="headerlink" title="安装erlang"></a>安装erlang</h3><p><img src="assets/1542502251460.png" alt="1542502251460"></p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><img src="assets/1542502390155.png" alt="1542502390155"></p><p><img src="assets/1542502423843.png" alt="1542502423843"></p><h3 id="启动rabbitmq管理界面"><a href="#启动rabbitmq管理界面" class="headerlink" title="启动rabbitmq管理界面"></a>启动rabbitmq管理界面</h3><p><img src="assets/1542502115646.png" alt="1542502115646"></p><h3 id="重启RabbitMQ服务"><a href="#重启RabbitMQ服务" class="headerlink" title="重启RabbitMQ服务"></a>重启RabbitMQ服务</h3><p><img src="assets/1542502176676.png" alt="1542502176676"></p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p><img src="assets/1542534338931.png" alt="1542534338931"></p><h2 id="5-RabbitMQ研究-入门程序-生产者-23分18秒"><a href="#5-RabbitMQ研究-入门程序-生产者-23分18秒" class="headerlink" title="5.RabbitMQ研究-入门程序-生产者 (23分18秒)"></a>5.RabbitMQ研究-入门程序-生产者 (23分18秒)</h2><p><img src="assets/1542535212320.png" alt="1542535212320"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rabbitmq的入门程序</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立新连接</span></span><br><span class="line">            connection = connectionFactory.newConnection();</span><br><span class="line">            <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">            channel = connection.createChannel();</span><br><span class="line">            <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">            <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细</span></span><br><span class="line"><span class="comment">             * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">             * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">             * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">             * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">             * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.queueDeclare(QUEUE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            <span class="comment">//参数：String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 参数明细：</span></span><br><span class="line"><span class="comment">             * 1、exchange，交换机，如果不指定将使用mq的默认交换机（设置为""）</span></span><br><span class="line"><span class="comment">             * 2、routingKey，路由key，交换机根据路由key来将消息转发到指定的队列，如果使用默认交换机，routingKey设置为队列的名称</span></span><br><span class="line"><span class="comment">             * 3、props，消息的属性</span></span><br><span class="line"><span class="comment">             * 4、body，消息内容</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//消息内容</span></span><br><span class="line">            String message = <span class="string">"hello world 黑马程序员"</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">"send to mq "</span>+message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            <span class="comment">//先关闭通道</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="assets/1542534402655.png" alt="1542534402655"></p><h2 id="6-RabbitMQ研究-入门程序-消费者-16分47秒"><a href="#6-RabbitMQ研究-入门程序-消费者-16分47秒" class="headerlink" title="6.RabbitMQ研究-入门程序-消费者 (16分47秒)"></a>6.RabbitMQ研究-入门程序-消费者 (16分47秒)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xuecheng.test.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入门程序消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2018-06-17 9:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接工厂创建新的连接和mq建立连接</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        connectionFactory.setPort(<span class="number">5672</span>);<span class="comment">//端口</span></span><br><span class="line">        connectionFactory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        connectionFactory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">//设置虚拟机，一个mq服务可以设置多个虚拟机，每个虚拟机就相当于一个独立的mq</span></span><br><span class="line">        connectionFactory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立新连接</span></span><br><span class="line">        Connection connection = connectionFactory.newConnection();</span><br><span class="line">        <span class="comment">//创建会话通道,生产者和mq服务所有通信都在channel通道中完成</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//声明队列，如果队列在mq 中没有则要创建</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、durable 是否持久化，如果持久化，mq重启后队列还在</span></span><br><span class="line"><span class="comment">         * 3、exclusive 是否独占连接，队列只允许在该连接中访问，如果connection连接关闭队列则自动删除,如果将此参数设置true可用于临时队列的创建</span></span><br><span class="line"><span class="comment">         * 4、autoDelete 自动删除，队列不再使用时是否自动删除此队列，如果将此参数和exclusive参数设置为true就可以实现临时队列（队列不用了就自动删除）</span></span><br><span class="line"><span class="comment">         * 5、arguments 参数，可以设置一个队列的扩展参数，比如：可设置存活时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(QUEUE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实现消费方法</span></span><br><span class="line">        DefaultConsumer defaultConsumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当接收到消息后此方法将被调用</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag  消费者标签，用来标识消费者的，在监听队列时设置channel.basicConsume</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 信封，通过envelope</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 消息属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息内容</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//交换机</span></span><br><span class="line">                String exchange = envelope.getExchange();</span><br><span class="line">                <span class="comment">//消息id，mq在channel中用来标识消息的id，可用于确认消息已接收</span></span><br><span class="line">                <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">                <span class="comment">//消息内容</span></span><br><span class="line">                String message= <span class="keyword">new</span> String(body,<span class="string">"utf-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"receive message:"</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听队列</span></span><br><span class="line">        <span class="comment">//参数：String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数明细：</span></span><br><span class="line"><span class="comment">         * 1、queue 队列名称</span></span><br><span class="line"><span class="comment">         * 2、autoAck 自动回复，当消费者接收到消息后要告诉mq消息已接收，如果将此参数设置为tru表示会自动回复mq，如果设置为false要通过编程实现回复</span></span><br><span class="line"><span class="comment">         * 3、callback，消费方法，当消费者接收到消息要执行的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(QUEUE,<span class="keyword">true</span>,defaultConsumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动Consumer01，程序不会自动结束，此时运行Producer01就会发送消息，Consumer01就会直接接收到消息。</p><p><img src="assets/1542534520399.png" alt="1542534520399"></p><p>Mq中不会显示待发消息了</p><p><img src="assets/1542534622822.png" alt="1542534622822"></p><h2 id="7-RabbitMQ研究-工作模式-工作队列模式-7分10秒"><a href="#7-RabbitMQ研究-工作模式-工作队列模式-7分10秒" class="headerlink" title="7.RabbitMQ研究-工作模式-工作队列模式 (7分10秒)"></a>7.RabbitMQ研究-工作模式-工作队列模式 (7分10秒)</h2><p>RabbitMQ有以下几种工作模式 ：<br>1、Work queues<br>2、Publish/Subscribe<br>3、Routing<br>4、Topics<br>5、Header<br>6、RPC</p><p><img src="assets/1542534883570.png" alt="1542534883570"></p><p>启动多个Consumer，会轮询接收消息。</p><h2 id="8-RabbitMQ研究-工作模式-发布订阅模式-生产者-15分17秒"><a href="#8-RabbitMQ研究-工作模式-发布订阅模式-生产者-15分17秒" class="headerlink" title="8.RabbitMQ研究-工作模式-发布订阅模式-生产者 (15分17秒)"></a>8.RabbitMQ研究-工作模式-发布订阅模式-生产者 (15分17秒)</h2><p><img src="assets/1542535226948.png" alt="1542535226948"></p><h3 id="发布订阅模式："><a href="#发布订阅模式：" class="headerlink" title="发布订阅模式："></a>发布订阅模式：</h3><p>1、每个消费者监听自己的队列。<br>2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收<br>到消息</p><h2 id="9-RabbitMQ研究-工作模式-发布订阅模式-消费者-11分9秒"><a href="#9-RabbitMQ研究-工作模式-发布订阅模式-消费者-11分9秒" class="headerlink" title="9.RabbitMQ研究-工作模式-发布订阅模式-消费者 (11分9秒)"></a>9.RabbitMQ研究-工作模式-发布订阅模式-消费者 (11分9秒)</h2><h2 id="10-RabbitMQ研究-工作模式-路由工作模式介绍-5分53秒"><a href="#10-RabbitMQ研究-工作模式-路由工作模式介绍-5分53秒" class="headerlink" title="10.RabbitMQ研究-工作模式-路由工作模式介绍 (5分53秒)"></a>10.RabbitMQ研究-工作模式-路由工作模式介绍 (5分53秒)</h2><p><img src="assets/1542538737391.png" alt="1542538737391"></p><p>路由模式：<br>1、每个消费者监听自己的队列，并且设置routingkey。<br>2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。</p><h2 id="11-RabbitMQ研究-工作模式-路由工作模式测试-12分59秒"><a href="#11-RabbitMQ研究-工作模式-路由工作模式测试-12分59秒" class="headerlink" title="11.RabbitMQ研究-工作模式-路由工作模式测试 (12分59秒)"></a>11.RabbitMQ研究-工作模式-路由工作模式测试 (12分59秒)</h2><h2 id="12-RabbitMQ研究-工作模式-统配符工作模式测试-16分29秒"><a href="#12-RabbitMQ研究-工作模式-统配符工作模式测试-16分29秒" class="headerlink" title="12.RabbitMQ研究-工作模式-统配符工作模式测试 (16分29秒)"></a>12.RabbitMQ研究-工作模式-统配符工作模式测试 (16分29秒)</h2><p><img src="assets/1542538850709.png" alt="1542538850709"></p><p>路由模式：<br>1、每个消费者监听自己的队列，并且设置带统配符的routingkey。<br>2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p><h2 id="13-RabbitMQ研究-工作模式-header和rpc工作模式-5分47秒"><a href="#13-RabbitMQ研究-工作模式-header和rpc工作模式-5分47秒" class="headerlink" title="13.RabbitMQ研究-工作模式-header和rpc工作模式 (5分47秒)"></a>13.RabbitMQ研究-工作模式-header和rpc工作模式 (5分47秒)</h2><p>header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配<br>队列。<br>案例：<br>根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种<br>通知类型都接收的则两种通知都有效。</p><p><img src="assets/1542538910666.png" alt="1542538910666"></p><p>RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：<br>1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。<br>2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果<br>3、服务端将RPC方法 的结果发送到RPC响应队列<br>4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。</p><h2 id="14-RabbitMQ研究-与springboot整合-搭建环境-5分56秒"><a href="#14-RabbitMQ研究-与springboot整合-搭建环境-5分56秒" class="headerlink" title="14.RabbitMQ研究-与springboot整合-搭建环境 (5分56秒)"></a>14.RabbitMQ研究-与springboot整合-搭建环境 (5分56秒)</h2><h2 id="15-RabbitMQ研究-与springboot整合-声明交换机和队列-6分48秒"><a href="#15-RabbitMQ研究-与springboot整合-声明交换机和队列-6分48秒" class="headerlink" title="15.RabbitMQ研究-与springboot整合-声明交换机和队列 (6分48秒)"></a>15.RabbitMQ研究-与springboot整合-声明交换机和队列 (6分48秒)</h2><h2 id="16-RabbitMQ研究-与springboot整合-生产者代码-6分12秒"><a href="#16-RabbitMQ研究-与springboot整合-生产者代码-6分12秒" class="headerlink" title="16.RabbitMQ研究-与springboot整合-生产者代码 (6分12秒)"></a>16.RabbitMQ研究-与springboot整合-生产者代码 (6分12秒)</h2><h2 id="17-RabbitMQ研究-与springboot整合-消费者代码-6分15秒"><a href="#17-RabbitMQ研究-与springboot整合-消费者代码-6分15秒" class="headerlink" title="17.RabbitMQ研究-与springboot整合-消费者代码 (6分15秒)"></a>17.RabbitMQ研究-与springboot整合-消费者代码 (6分15秒)</h2>]]></content>
    
    <summary type="html">
    
      消息队列知识点整理
    
    </summary>
    
    
      <category term="消息队列" scheme="http://gxblog.club/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="消息队列" scheme="http://gxblog.club/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
